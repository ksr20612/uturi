"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@zag-js+rect-utils@1.21.7";
exports.ids = ["vendor-chunks/@zag-js+rect-utils@1.21.7"];
exports.modules = {

/***/ "(ssr)/../../node_modules/.pnpm/@zag-js+rect-utils@1.21.7/node_modules/@zag-js/rect-utils/dist/index.mjs":
/*!*********************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@zag-js+rect-utils@1.21.7/node_modules/@zag-js/rect-utils/dist/index.mjs ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AffineTransform: () => (/* binding */ AffineTransform),\n/* harmony export */   addPoints: () => (/* binding */ addPoints),\n/* harmony export */   alignRect: () => (/* binding */ alignRect),\n/* harmony export */   clampPoint: () => (/* binding */ clampPoint),\n/* harmony export */   clampSize: () => (/* binding */ clampSize),\n/* harmony export */   closest: () => (/* binding */ closest),\n/* harmony export */   closestSideToPoint: () => (/* binding */ closestSideToPoint),\n/* harmony export */   closestSideToRect: () => (/* binding */ closestSideToRect),\n/* harmony export */   collisions: () => (/* binding */ collisions),\n/* harmony export */   constrainRect: () => (/* binding */ constrainRect),\n/* harmony export */   contains: () => (/* binding */ contains),\n/* harmony export */   containsPoint: () => (/* binding */ containsPoint),\n/* harmony export */   containsRect: () => (/* binding */ containsRect),\n/* harmony export */   createPoint: () => (/* binding */ createPoint),\n/* harmony export */   createRect: () => (/* binding */ createRect),\n/* harmony export */   debugPolygon: () => (/* binding */ debugPolygon),\n/* harmony export */   distance: () => (/* binding */ distance),\n/* harmony export */   distanceBtwEdges: () => (/* binding */ distanceBtwEdges),\n/* harmony export */   distanceFromPoint: () => (/* binding */ distanceFromPoint),\n/* harmony export */   distanceFromRect: () => (/* binding */ distanceFromRect),\n/* harmony export */   expand: () => (/* binding */ expand),\n/* harmony export */   fromRange: () => (/* binding */ fromRange),\n/* harmony export */   getElementPolygon: () => (/* binding */ getElementPolygon),\n/* harmony export */   getElementRect: () => (/* binding */ getElementRect),\n/* harmony export */   getPointAngle: () => (/* binding */ getPointAngle),\n/* harmony export */   getRectCenters: () => (/* binding */ getRectCenters),\n/* harmony export */   getRectCorners: () => (/* binding */ getRectCorners),\n/* harmony export */   getRectEdges: () => (/* binding */ getRectEdges),\n/* harmony export */   getRectFromPoints: () => (/* binding */ getRectFromPoints),\n/* harmony export */   getRotationRect: () => (/* binding */ getRotationRect),\n/* harmony export */   getViewportRect: () => (/* binding */ getViewportRect),\n/* harmony export */   getWindowRect: () => (/* binding */ getWindowRect),\n/* harmony export */   inset: () => (/* binding */ inset),\n/* harmony export */   intersection: () => (/* binding */ intersection),\n/* harmony export */   intersects: () => (/* binding */ intersects),\n/* harmony export */   isPoint: () => (/* binding */ isPoint),\n/* harmony export */   isPointEqual: () => (/* binding */ isPointEqual),\n/* harmony export */   isPointInPolygon: () => (/* binding */ isPointInPolygon),\n/* harmony export */   isRect: () => (/* binding */ isRect),\n/* harmony export */   isRectEqual: () => (/* binding */ isRectEqual),\n/* harmony export */   isSizeEqual: () => (/* binding */ isSizeEqual),\n/* harmony export */   isSymmetric: () => (/* binding */ isSymmetric),\n/* harmony export */   resizeRect: () => (/* binding */ resizeRect),\n/* harmony export */   rotate: () => (/* binding */ rotate),\n/* harmony export */   shift: () => (/* binding */ shift),\n/* harmony export */   shrink: () => (/* binding */ shrink),\n/* harmony export */   subtractPoints: () => (/* binding */ subtractPoints),\n/* harmony export */   toRad: () => (/* binding */ toRad),\n/* harmony export */   union: () => (/* binding */ union)\n/* harmony export */ });\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n\n// src/affine-transform.ts\nvar AffineTransform = class _AffineTransform {\n  constructor([m00, m01, m02, m10, m11, m12] = [0, 0, 0, 0, 0, 0]) {\n    __publicField(this, \"m00\");\n    __publicField(this, \"m01\");\n    __publicField(this, \"m02\");\n    __publicField(this, \"m10\");\n    __publicField(this, \"m11\");\n    __publicField(this, \"m12\");\n    __publicField(this, \"rotate\", (...args) => {\n      return this.prepend(_AffineTransform.rotate(...args));\n    });\n    __publicField(this, \"scale\", (...args) => {\n      return this.prepend(_AffineTransform.scale(...args));\n    });\n    __publicField(this, \"translate\", (...args) => {\n      return this.prepend(_AffineTransform.translate(...args));\n    });\n    this.m00 = m00;\n    this.m01 = m01;\n    this.m02 = m02;\n    this.m10 = m10;\n    this.m11 = m11;\n    this.m12 = m12;\n  }\n  applyTo(point) {\n    const { x, y } = point;\n    const { m00, m01, m02, m10, m11, m12 } = this;\n    return {\n      x: m00 * x + m01 * y + m02,\n      y: m10 * x + m11 * y + m12\n    };\n  }\n  prepend(other) {\n    return new _AffineTransform([\n      this.m00 * other.m00 + this.m01 * other.m10,\n      // m00\n      this.m00 * other.m01 + this.m01 * other.m11,\n      // m01\n      this.m00 * other.m02 + this.m01 * other.m12 + this.m02,\n      // m02\n      this.m10 * other.m00 + this.m11 * other.m10,\n      // m10\n      this.m10 * other.m01 + this.m11 * other.m11,\n      // m11\n      this.m10 * other.m02 + this.m11 * other.m12 + this.m12\n      // m12\n    ]);\n  }\n  append(other) {\n    return new _AffineTransform([\n      other.m00 * this.m00 + other.m01 * this.m10,\n      // m00\n      other.m00 * this.m01 + other.m01 * this.m11,\n      // m01\n      other.m00 * this.m02 + other.m01 * this.m12 + other.m02,\n      // m02\n      other.m10 * this.m00 + other.m11 * this.m10,\n      // m10\n      other.m10 * this.m01 + other.m11 * this.m11,\n      // m11\n      other.m10 * this.m02 + other.m11 * this.m12 + other.m12\n      // m12\n    ]);\n  }\n  get determinant() {\n    return this.m00 * this.m11 - this.m01 * this.m10;\n  }\n  get isInvertible() {\n    const det = this.determinant;\n    return isFinite(det) && isFinite(this.m02) && isFinite(this.m12) && det !== 0;\n  }\n  invert() {\n    const det = this.determinant;\n    return new _AffineTransform([\n      this.m11 / det,\n      // m00\n      -this.m01 / det,\n      // m01\n      (this.m01 * this.m12 - this.m11 * this.m02) / det,\n      // m02\n      -this.m10 / det,\n      // m10\n      this.m00 / det,\n      // m11\n      (this.m10 * this.m02 - this.m00 * this.m12) / det\n      // m12\n    ]);\n  }\n  get array() {\n    return [this.m00, this.m01, this.m02, this.m10, this.m11, this.m12, 0, 0, 1];\n  }\n  get float32Array() {\n    return new Float32Array(this.array);\n  }\n  // Static\n  static get identity() {\n    return new _AffineTransform([1, 0, 0, 0, 1, 0]);\n  }\n  static rotate(theta, origin) {\n    const rotation = new _AffineTransform([Math.cos(theta), -Math.sin(theta), 0, Math.sin(theta), Math.cos(theta), 0]);\n    if (origin && (origin.x !== 0 || origin.y !== 0)) {\n      return _AffineTransform.multiply(\n        _AffineTransform.translate(origin.x, origin.y),\n        rotation,\n        _AffineTransform.translate(-origin.x, -origin.y)\n      );\n    }\n    return rotation;\n  }\n  static scale(sx, sy = sx, origin = { x: 0, y: 0 }) {\n    const scale = new _AffineTransform([sx, 0, 0, 0, sy, 0]);\n    if (origin.x !== 0 || origin.y !== 0) {\n      return _AffineTransform.multiply(\n        _AffineTransform.translate(origin.x, origin.y),\n        scale,\n        _AffineTransform.translate(-origin.x, -origin.y)\n      );\n    }\n    return scale;\n  }\n  static translate(tx, ty) {\n    return new _AffineTransform([1, 0, tx, 0, 1, ty]);\n  }\n  static multiply(...[first, ...rest]) {\n    if (!first) return _AffineTransform.identity;\n    return rest.reduce((result, item) => result.prepend(item), first);\n  }\n  get a() {\n    return this.m00;\n  }\n  get b() {\n    return this.m10;\n  }\n  get c() {\n    return this.m01;\n  }\n  get d() {\n    return this.m11;\n  }\n  get tx() {\n    return this.m02;\n  }\n  get ty() {\n    return this.m12;\n  }\n  get scaleComponents() {\n    return { x: this.a, y: this.d };\n  }\n  get translationComponents() {\n    return { x: this.tx, y: this.ty };\n  }\n  get skewComponents() {\n    return { x: this.c, y: this.b };\n  }\n  toString() {\n    return `matrix(${this.a}, ${this.b}, ${this.c}, ${this.d}, ${this.tx}, ${this.ty})`;\n  }\n};\n\n// src/align.ts\nfunction hAlign(a, ref, h) {\n  let x = ref.minX;\n  if (h === \"left-inside\") x = ref.minX;\n  if (h === \"left-outside\") x = ref.minX - ref.width;\n  if (h === \"right-inside\") x = ref.maxX - ref.width;\n  if (h === \"right-outside\") x = ref.maxX;\n  if (h === \"center\") x = ref.midX - ref.width / 2;\n  return { ...a, x };\n}\nfunction vAlign(a, ref, v) {\n  let y = ref.minY;\n  if (v === \"top-inside\") y = ref.minY;\n  if (v === \"top-outside\") y = ref.minY - a.height;\n  if (v === \"bottom-inside\") y = ref.maxY - a.height;\n  if (v === \"bottom-outside\") y = ref.maxY;\n  if (v === \"center\") y = ref.midY - a.height / 2;\n  return { ...a, y };\n}\nfunction alignRect(a, ref, options) {\n  const { h, v } = options;\n  return vAlign(hAlign(a, ref, h), ref, v);\n}\n\n// src/angle.ts\nfunction getPointAngle(rect, point, reference = rect.center) {\n  const x = point.x - reference.x;\n  const y = point.y - reference.y;\n  const deg = Math.atan2(x, y) * (180 / Math.PI) + 180;\n  return 360 - deg;\n}\n\n// src/clamp.ts\nvar clamp = (value, min3, max2) => Math.min(Math.max(value, min3), max2);\nvar clampPoint = (position, size, boundaryRect) => {\n  const x = clamp(position.x, boundaryRect.x, boundaryRect.x + boundaryRect.width - size.width);\n  const y = clamp(position.y, boundaryRect.y, boundaryRect.y + boundaryRect.height - size.height);\n  return { x, y };\n};\nvar defaultMinSize = {\n  width: 0,\n  height: 0\n};\nvar defaultMaxSize = {\n  width: Infinity,\n  height: Infinity\n};\nvar clampSize = (size, minSize = defaultMinSize, maxSize = defaultMaxSize) => {\n  return {\n    width: Math.min(Math.max(size.width, minSize.width), maxSize.width),\n    height: Math.min(Math.max(size.height, minSize.height), maxSize.height)\n  };\n};\n\n// src/rect.ts\nvar createPoint = (x, y) => ({ x, y });\nvar subtractPoints = (a, b) => {\n  if (!b) return a;\n  return createPoint(a.x - b.x, a.y - b.y);\n};\nvar addPoints = (a, b) => createPoint(a.x + b.x, a.y + b.y);\nfunction isPoint(v) {\n  return Reflect.has(v, \"x\") && Reflect.has(v, \"y\");\n}\nfunction createRect(r) {\n  const { x, y, width, height } = r;\n  const midX = x + width / 2;\n  const midY = y + height / 2;\n  return {\n    x,\n    y,\n    width,\n    height,\n    minX: x,\n    minY: y,\n    maxX: x + width,\n    maxY: y + height,\n    midX,\n    midY,\n    center: createPoint(midX, midY)\n  };\n}\nfunction isRect(v) {\n  return Reflect.has(v, \"x\") && Reflect.has(v, \"y\") && Reflect.has(v, \"width\") && Reflect.has(v, \"height\");\n}\nfunction getRectCenters(v) {\n  const top = createPoint(v.midX, v.minY);\n  const right = createPoint(v.maxX, v.midY);\n  const bottom = createPoint(v.midX, v.maxY);\n  const left = createPoint(v.minX, v.midY);\n  return { top, right, bottom, left };\n}\nfunction getRectCorners(v) {\n  const top = createPoint(v.minX, v.minY);\n  const right = createPoint(v.maxX, v.minY);\n  const bottom = createPoint(v.maxX, v.maxY);\n  const left = createPoint(v.minX, v.maxY);\n  return { top, right, bottom, left };\n}\nfunction getRectEdges(v) {\n  const c = getRectCorners(v);\n  const top = [c.top, c.right];\n  const right = [c.right, c.bottom];\n  const bottom = [c.left, c.bottom];\n  const left = [c.top, c.left];\n  return { top, right, bottom, left };\n}\n\n// src/intersection.ts\nfunction intersects(a, b) {\n  return a.x < b.maxX && a.y < b.maxY && a.maxX > b.x && a.maxY > b.y;\n}\nfunction intersection(a, b) {\n  const x = Math.max(a.x, b.x);\n  const y = Math.max(a.y, b.y);\n  const x2 = Math.min(a.x + a.width, b.x + b.width);\n  const y2 = Math.min(a.y + a.height, b.y + b.height);\n  return createRect({ x, y, width: x2 - x, height: y2 - y });\n}\nfunction collisions(a, b) {\n  return {\n    top: a.minY <= b.minY,\n    right: a.maxX >= b.maxX,\n    bottom: a.maxY >= b.maxY,\n    left: a.minX <= b.minX\n  };\n}\n\n// src/distance.ts\nfunction distance(a, b = { x: 0, y: 0 }) {\n  return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));\n}\nfunction distanceFromPoint(r, p) {\n  let x = 0;\n  let y = 0;\n  if (p.x < r.x) x = r.x - p.x;\n  else if (p.x > r.maxX) x = p.x - r.maxX;\n  if (p.y < r.y) y = r.y - p.y;\n  else if (p.y > r.maxY) y = p.y - r.maxY;\n  return { x, y, value: distance({ x, y }) };\n}\nfunction distanceFromRect(a, b) {\n  if (intersects(a, b)) return { x: 0, y: 0, value: 0 };\n  const left = a.x < b.x ? a : b;\n  const right = b.x < a.x ? a : b;\n  const upper = a.y < b.y ? a : b;\n  const lower = b.y < a.y ? a : b;\n  let x = left.x === right.x ? 0 : right.x - left.maxX;\n  x = Math.max(0, x);\n  let y = upper.y === lower.y ? 0 : lower.y - upper.maxY;\n  y = Math.max(0, y);\n  return { x, y, value: distance({ x, y }) };\n}\nfunction distanceBtwEdges(a, b) {\n  return {\n    left: b.x - a.x,\n    top: b.y - a.y,\n    right: a.maxX - b.maxX,\n    bottom: a.maxY - b.maxY\n  };\n}\n\n// src/closest.ts\nfunction closest(...pts) {\n  return (a) => {\n    const ds = pts.map((b) => distance(b, a));\n    const c = Math.min.apply(Math, ds);\n    return pts[ds.indexOf(c)];\n  };\n}\nfunction closestSideToRect(ref, r) {\n  if (r.maxX <= ref.minX) return \"left\";\n  if (r.minX >= ref.maxX) return \"right\";\n  if (r.maxY <= ref.minY) return \"top\";\n  if (r.minY >= ref.maxY) return \"bottom\";\n  return \"left\";\n}\nfunction closestSideToPoint(ref, p) {\n  const { x, y } = p;\n  const dl = x - ref.minX;\n  const dr = ref.maxX - x;\n  const dt = y - ref.minY;\n  const db = ref.maxY - y;\n  let closest2 = dl;\n  let side = \"left\";\n  if (dr < closest2) {\n    closest2 = dr;\n    side = \"right\";\n  }\n  if (dt < closest2) {\n    closest2 = dt;\n    side = \"top\";\n  }\n  if (db < closest2) {\n    side = \"bottom\";\n  }\n  return side;\n}\n\n// src/constrain.ts\nvar constrainRect = (rect, boundary) => {\n  const left = Math.max(boundary.x, Math.min(rect.x, boundary.x + boundary.width - rect.width));\n  const top = Math.max(boundary.y, Math.min(rect.y, boundary.y + boundary.height - rect.height));\n  return {\n    x: left,\n    y: top,\n    width: Math.min(rect.width, boundary.width),\n    height: Math.min(rect.height, boundary.height)\n  };\n};\n\n// src/contains.ts\nfunction containsPoint(r, p) {\n  return r.minX <= p.x && p.x <= r.maxX && r.minY <= p.y && p.y <= r.maxY;\n}\nfunction containsRect(a, b) {\n  return Object.values(getRectCorners(b)).every((c) => containsPoint(a, c));\n}\nfunction contains(r, v) {\n  return isRect(v) ? containsRect(r, v) : containsPoint(r, v);\n}\n\n// src/equality.ts\nvar isSizeEqual = (a, b) => {\n  return a.width === b?.width && a.height === b?.height;\n};\nvar isPointEqual = (a, b) => {\n  return a.x === b?.x && a.y === b?.y;\n};\nvar isRectEqual = (a, b) => {\n  return isPointEqual(a, b) && isSizeEqual(a, b);\n};\n\n// src/from-element.ts\nvar styleCache = /* @__PURE__ */ new WeakMap();\nfunction getCacheComputedStyle(el) {\n  if (!styleCache.has(el)) {\n    const win = el.ownerDocument.defaultView || window;\n    styleCache.set(el, win.getComputedStyle(el));\n  }\n  return styleCache.get(el);\n}\nfunction getElementRect(el, opts = {}) {\n  return createRect(getClientRect(el, opts));\n}\nfunction getClientRect(el, opts = {}) {\n  const { excludeScrollbar = false, excludeBorders = false } = opts;\n  const { x, y, width, height } = el.getBoundingClientRect();\n  const r = { x, y, width, height };\n  const style = getCacheComputedStyle(el);\n  const { borderLeftWidth, borderTopWidth, borderRightWidth, borderBottomWidth } = style;\n  const borderXWidth = sum(borderLeftWidth, borderRightWidth);\n  const borderYWidth = sum(borderTopWidth, borderBottomWidth);\n  if (excludeBorders) {\n    r.width -= borderXWidth;\n    r.height -= borderYWidth;\n    r.x += px(borderLeftWidth);\n    r.y += px(borderTopWidth);\n  }\n  if (excludeScrollbar) {\n    const scrollbarWidth = el.offsetWidth - el.clientWidth - borderXWidth;\n    const scrollbarHeight = el.offsetHeight - el.clientHeight - borderYWidth;\n    r.width -= scrollbarWidth;\n    r.height -= scrollbarHeight;\n  }\n  return r;\n}\nvar px = (v) => parseFloat(v.replace(\"px\", \"\"));\nvar sum = (...vals) => vals.reduce((sum2, v) => sum2 + (v ? px(v) : 0), 0);\n\n// src/from-points.ts\nfunction getRectFromPoints(...pts) {\n  const xs = pts.map((p) => p.x);\n  const ys = pts.map((p) => p.y);\n  const x = Math.min(...xs);\n  const y = Math.min(...ys);\n  const width = Math.max(...xs) - x;\n  const height = Math.max(...ys) - y;\n  return createRect({ x, y, width, height });\n}\n\n// src/union.ts\nvar { min, max } = Math;\nfunction union(...rs) {\n  const pMin = {\n    x: min(...rs.map((r) => r.minX)),\n    y: min(...rs.map((r) => r.minY))\n  };\n  const pMax = {\n    x: max(...rs.map((r) => r.maxX)),\n    y: max(...rs.map((r) => r.maxY))\n  };\n  return getRectFromPoints(pMin, pMax);\n}\n\n// src/from-range.ts\nfunction fromRange(range) {\n  let rs = [];\n  const rects = Array.from(range.getClientRects());\n  if (rects.length) {\n    rs = rs.concat(rects.map(createRect));\n    return union.apply(void 0, rs);\n  }\n  let start = range.startContainer;\n  if (start.nodeType === Node.TEXT_NODE) {\n    start = start.parentNode;\n  }\n  if (start instanceof HTMLElement) {\n    const r = getElementRect(start);\n    rs.push({ ...r, x: r.maxX, width: 0 });\n  }\n  return union.apply(void 0, rs);\n}\n\n// src/from-rotation.ts\nfunction toRad(d) {\n  return d % 360 * Math.PI / 180;\n}\nfunction rotate(a, d, c) {\n  const r = toRad(d);\n  const sin = Math.sin(r);\n  const cos = Math.cos(r);\n  const x = a.x - c.x;\n  const y = a.y - c.y;\n  return {\n    x: c.x + x * cos - y * sin,\n    y: c.y + x * sin + y * cos\n  };\n}\nfunction getRotationRect(r, deg) {\n  const rr = Object.values(getRectCorners(r)).map((p) => rotate(p, deg, r.center));\n  const xs = rr.map((p) => p.x);\n  const ys = rr.map((p) => p.y);\n  const minX = Math.min(...xs);\n  const minY = Math.min(...ys);\n  const maxX = Math.max(...xs);\n  const maxY = Math.max(...ys);\n  return createRect({\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  });\n}\n\n// src/from-window.ts\nfunction getWindowRect(win, opts = {}) {\n  return createRect(getViewportRect(win, opts));\n}\nfunction getViewportRect(win, opts) {\n  const { excludeScrollbar = false } = opts;\n  const { innerWidth, innerHeight, document: doc, visualViewport } = win;\n  const width = visualViewport?.width || innerWidth;\n  const height = visualViewport?.height || innerHeight;\n  const rect = { x: 0, y: 0, width, height };\n  if (excludeScrollbar) {\n    const scrollbarWidth = innerWidth - doc.documentElement.clientWidth;\n    const scrollbarHeight = innerHeight - doc.documentElement.clientHeight;\n    rect.width -= scrollbarWidth;\n    rect.height -= scrollbarHeight;\n  }\n  return rect;\n}\n\n// src/operations.ts\nvar isSymmetric = (v) => \"dx\" in v || \"dy\" in v;\nfunction inset(r, i) {\n  const v = isSymmetric(i) ? { left: i.dx, right: i.dx, top: i.dy, bottom: i.dy } : i;\n  const { top = 0, right = 0, bottom = 0, left = 0 } = v;\n  return createRect({\n    x: r.x + left,\n    y: r.y + top,\n    width: r.width - left - right,\n    height: r.height - top - bottom\n  });\n}\nfunction expand(r, v) {\n  const value = typeof v === \"number\" ? { dx: -v, dy: -v } : v;\n  return inset(r, value);\n}\nfunction shrink(r, v) {\n  const value = typeof v === \"number\" ? { dx: -v, dy: -v } : v;\n  return inset(r, value);\n}\nfunction shift(r, o) {\n  const { x = 0, y = 0 } = o;\n  return createRect({\n    x: r.x + x,\n    y: r.y + y,\n    width: r.width,\n    height: r.height\n  });\n}\n\n// src/polygon.ts\nfunction getElementPolygon(rectValue, placement) {\n  const rect = createRect(rectValue);\n  const { top, right, left, bottom } = getRectCorners(rect);\n  const [base] = placement.split(\"-\");\n  return {\n    top: [left, top, right, bottom],\n    right: [top, right, bottom, left],\n    bottom: [top, left, bottom, right],\n    left: [right, top, left, bottom]\n  }[base];\n}\nfunction isPointInPolygon(polygon, point) {\n  const { x, y } = point;\n  let c = false;\n  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n    const xi = polygon[i].x;\n    const yi = polygon[i].y;\n    const xj = polygon[j].x;\n    const yj = polygon[j].y;\n    if (yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi) {\n      c = !c;\n    }\n  }\n  return c;\n}\nfunction createPolygonElement() {\n  const id = \"debug-polygon\";\n  const existingPolygon = document.getElementById(id);\n  if (existingPolygon) {\n    return existingPolygon;\n  }\n  const svg = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n  Object.assign(svg.style, {\n    top: \"0\",\n    left: \"0\",\n    width: \"100%\",\n    height: \"100%\",\n    opacity: \"0.15\",\n    position: \"fixed\",\n    pointerEvents: \"none\",\n    fill: \"red\"\n  });\n  const polygon = document.createElementNS(\"http://www.w3.org/2000/svg\", \"polygon\");\n  polygon.setAttribute(\"id\", id);\n  polygon.setAttribute(\"points\", \"0,0 0,0\");\n  svg.appendChild(polygon);\n  document.body.appendChild(svg);\n  return polygon;\n}\nfunction debugPolygon(polygon) {\n  const el = createPolygonElement();\n  const points = polygon.map((point) => `${point.x},${point.y}`).join(\" \");\n  el.setAttribute(\"points\", points);\n  return () => {\n    el.remove();\n  };\n}\n\n// src/compass.ts\nvar compassDirectionMap = {\n  n: { x: 0.5, y: 0 },\n  ne: { x: 1, y: 0 },\n  e: { x: 1, y: 0.5 },\n  se: { x: 1, y: 1 },\n  s: { x: 0.5, y: 1 },\n  sw: { x: 0, y: 1 },\n  w: { x: 0, y: 0.5 },\n  nw: { x: 0, y: 0 }\n};\nvar oppositeDirectionMap = {\n  n: \"s\",\n  ne: \"sw\",\n  e: \"w\",\n  se: \"nw\",\n  s: \"n\",\n  sw: \"ne\",\n  w: \"e\",\n  nw: \"se\"\n};\n\n// src/resize.ts\nvar { sign, abs, min: min2 } = Math;\nfunction getRectExtentPoint(rect, direction) {\n  const { minX, minY, maxX, maxY, midX, midY } = rect;\n  const x = direction.includes(\"w\") ? minX : direction.includes(\"e\") ? maxX : midX;\n  const y = direction.includes(\"n\") ? minY : direction.includes(\"s\") ? maxY : midY;\n  return { x, y };\n}\nfunction getOppositeDirection(direction) {\n  return oppositeDirectionMap[direction];\n}\nfunction resizeRect(rect, offset, direction, opts) {\n  const { scalingOriginMode, lockAspectRatio } = opts;\n  const extent = getRectExtentPoint(rect, direction);\n  const oppositeDirection = getOppositeDirection(direction);\n  const oppositeExtent = getRectExtentPoint(rect, oppositeDirection);\n  if (scalingOriginMode === \"center\") {\n    offset = { x: offset.x * 2, y: offset.y * 2 };\n  }\n  const newExtent = {\n    x: extent.x + offset.x,\n    y: extent.y + offset.y\n  };\n  const multiplier = {\n    x: compassDirectionMap[direction].x * 2 - 1,\n    y: compassDirectionMap[direction].y * 2 - 1\n  };\n  const newSize = {\n    width: newExtent.x - oppositeExtent.x,\n    height: newExtent.y - oppositeExtent.y\n  };\n  const scaleX = multiplier.x * newSize.width / rect.width;\n  const scaleY = multiplier.y * newSize.height / rect.height;\n  const largestMagnitude = abs(scaleX) > abs(scaleY) ? scaleX : scaleY;\n  const scale = lockAspectRatio ? { x: largestMagnitude, y: largestMagnitude } : {\n    x: extent.x === oppositeExtent.x ? 1 : scaleX,\n    y: extent.y === oppositeExtent.y ? 1 : scaleY\n  };\n  if (extent.y === oppositeExtent.y) {\n    scale.y = abs(scale.y);\n  } else if (sign(scale.y) !== sign(scaleY)) {\n    scale.y *= -1;\n  }\n  if (extent.x === oppositeExtent.x) {\n    scale.x = abs(scale.x);\n  } else if (sign(scale.x) !== sign(scaleX)) {\n    scale.x *= -1;\n  }\n  switch (scalingOriginMode) {\n    case \"extent\":\n      return transformRect(rect, AffineTransform.scale(scale.x, scale.y, oppositeExtent), false);\n    case \"center\":\n      return transformRect(\n        rect,\n        AffineTransform.scale(scale.x, scale.y, {\n          x: rect.midX,\n          y: rect.midY\n        }),\n        false\n      );\n  }\n}\nfunction createRectFromPoints(initialPoint, finalPoint, normalized = true) {\n  if (normalized) {\n    return {\n      x: min2(finalPoint.x, initialPoint.x),\n      y: min2(finalPoint.y, initialPoint.y),\n      width: abs(finalPoint.x - initialPoint.x),\n      height: abs(finalPoint.y - initialPoint.y)\n    };\n  }\n  return {\n    x: initialPoint.x,\n    y: initialPoint.y,\n    width: finalPoint.x - initialPoint.x,\n    height: finalPoint.y - initialPoint.y\n  };\n}\nfunction transformRect(rect, transform, normalized = true) {\n  const p1 = transform.applyTo({ x: rect.minX, y: rect.minY });\n  const p2 = transform.applyTo({ x: rect.maxX, y: rect.maxY });\n  return createRectFromPoints(p1, p2, normalized);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0B6YWctanMrcmVjdC11dGlsc0AxLjIxLjcvbm9kZV9tb2R1bGVzL0B6YWctanMvcmVjdC11dGlscy9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSwrQkFBK0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsWUFBWTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFFbXBCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHV0dXJpL3V0dXJpLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AemFnLWpzK3JlY3QtdXRpbHNAMS4yMS43L25vZGVfbW9kdWxlcy9AemFnLWpzL3JlY3QtdXRpbHMvZGlzdC9pbmRleC5tanM/YjMwYiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fcHVibGljRmllbGQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuXG4vLyBzcmMvYWZmaW5lLXRyYW5zZm9ybS50c1xudmFyIEFmZmluZVRyYW5zZm9ybSA9IGNsYXNzIF9BZmZpbmVUcmFuc2Zvcm0ge1xuICBjb25zdHJ1Y3RvcihbbTAwLCBtMDEsIG0wMiwgbTEwLCBtMTEsIG0xMl0gPSBbMCwgMCwgMCwgMCwgMCwgMF0pIHtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibTAwXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJtMDFcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm0wMlwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibTEwXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJtMTFcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm0xMlwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicm90YXRlXCIsICguLi5hcmdzKSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5wcmVwZW5kKF9BZmZpbmVUcmFuc2Zvcm0ucm90YXRlKC4uLmFyZ3MpKTtcbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwic2NhbGVcIiwgKC4uLmFyZ3MpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLnByZXBlbmQoX0FmZmluZVRyYW5zZm9ybS5zY2FsZSguLi5hcmdzKSk7XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInRyYW5zbGF0ZVwiLCAoLi4uYXJncykgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMucHJlcGVuZChfQWZmaW5lVHJhbnNmb3JtLnRyYW5zbGF0ZSguLi5hcmdzKSk7XG4gICAgfSk7XG4gICAgdGhpcy5tMDAgPSBtMDA7XG4gICAgdGhpcy5tMDEgPSBtMDE7XG4gICAgdGhpcy5tMDIgPSBtMDI7XG4gICAgdGhpcy5tMTAgPSBtMTA7XG4gICAgdGhpcy5tMTEgPSBtMTE7XG4gICAgdGhpcy5tMTIgPSBtMTI7XG4gIH1cbiAgYXBwbHlUbyhwb2ludCkge1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gcG9pbnQ7XG4gICAgY29uc3QgeyBtMDAsIG0wMSwgbTAyLCBtMTAsIG0xMSwgbTEyIH0gPSB0aGlzO1xuICAgIHJldHVybiB7XG4gICAgICB4OiBtMDAgKiB4ICsgbTAxICogeSArIG0wMixcbiAgICAgIHk6IG0xMCAqIHggKyBtMTEgKiB5ICsgbTEyXG4gICAgfTtcbiAgfVxuICBwcmVwZW5kKG90aGVyKSB7XG4gICAgcmV0dXJuIG5ldyBfQWZmaW5lVHJhbnNmb3JtKFtcbiAgICAgIHRoaXMubTAwICogb3RoZXIubTAwICsgdGhpcy5tMDEgKiBvdGhlci5tMTAsXG4gICAgICAvLyBtMDBcbiAgICAgIHRoaXMubTAwICogb3RoZXIubTAxICsgdGhpcy5tMDEgKiBvdGhlci5tMTEsXG4gICAgICAvLyBtMDFcbiAgICAgIHRoaXMubTAwICogb3RoZXIubTAyICsgdGhpcy5tMDEgKiBvdGhlci5tMTIgKyB0aGlzLm0wMixcbiAgICAgIC8vIG0wMlxuICAgICAgdGhpcy5tMTAgKiBvdGhlci5tMDAgKyB0aGlzLm0xMSAqIG90aGVyLm0xMCxcbiAgICAgIC8vIG0xMFxuICAgICAgdGhpcy5tMTAgKiBvdGhlci5tMDEgKyB0aGlzLm0xMSAqIG90aGVyLm0xMSxcbiAgICAgIC8vIG0xMVxuICAgICAgdGhpcy5tMTAgKiBvdGhlci5tMDIgKyB0aGlzLm0xMSAqIG90aGVyLm0xMiArIHRoaXMubTEyXG4gICAgICAvLyBtMTJcbiAgICBdKTtcbiAgfVxuICBhcHBlbmQob3RoZXIpIHtcbiAgICByZXR1cm4gbmV3IF9BZmZpbmVUcmFuc2Zvcm0oW1xuICAgICAgb3RoZXIubTAwICogdGhpcy5tMDAgKyBvdGhlci5tMDEgKiB0aGlzLm0xMCxcbiAgICAgIC8vIG0wMFxuICAgICAgb3RoZXIubTAwICogdGhpcy5tMDEgKyBvdGhlci5tMDEgKiB0aGlzLm0xMSxcbiAgICAgIC8vIG0wMVxuICAgICAgb3RoZXIubTAwICogdGhpcy5tMDIgKyBvdGhlci5tMDEgKiB0aGlzLm0xMiArIG90aGVyLm0wMixcbiAgICAgIC8vIG0wMlxuICAgICAgb3RoZXIubTEwICogdGhpcy5tMDAgKyBvdGhlci5tMTEgKiB0aGlzLm0xMCxcbiAgICAgIC8vIG0xMFxuICAgICAgb3RoZXIubTEwICogdGhpcy5tMDEgKyBvdGhlci5tMTEgKiB0aGlzLm0xMSxcbiAgICAgIC8vIG0xMVxuICAgICAgb3RoZXIubTEwICogdGhpcy5tMDIgKyBvdGhlci5tMTEgKiB0aGlzLm0xMiArIG90aGVyLm0xMlxuICAgICAgLy8gbTEyXG4gICAgXSk7XG4gIH1cbiAgZ2V0IGRldGVybWluYW50KCkge1xuICAgIHJldHVybiB0aGlzLm0wMCAqIHRoaXMubTExIC0gdGhpcy5tMDEgKiB0aGlzLm0xMDtcbiAgfVxuICBnZXQgaXNJbnZlcnRpYmxlKCkge1xuICAgIGNvbnN0IGRldCA9IHRoaXMuZGV0ZXJtaW5hbnQ7XG4gICAgcmV0dXJuIGlzRmluaXRlKGRldCkgJiYgaXNGaW5pdGUodGhpcy5tMDIpICYmIGlzRmluaXRlKHRoaXMubTEyKSAmJiBkZXQgIT09IDA7XG4gIH1cbiAgaW52ZXJ0KCkge1xuICAgIGNvbnN0IGRldCA9IHRoaXMuZGV0ZXJtaW5hbnQ7XG4gICAgcmV0dXJuIG5ldyBfQWZmaW5lVHJhbnNmb3JtKFtcbiAgICAgIHRoaXMubTExIC8gZGV0LFxuICAgICAgLy8gbTAwXG4gICAgICAtdGhpcy5tMDEgLyBkZXQsXG4gICAgICAvLyBtMDFcbiAgICAgICh0aGlzLm0wMSAqIHRoaXMubTEyIC0gdGhpcy5tMTEgKiB0aGlzLm0wMikgLyBkZXQsXG4gICAgICAvLyBtMDJcbiAgICAgIC10aGlzLm0xMCAvIGRldCxcbiAgICAgIC8vIG0xMFxuICAgICAgdGhpcy5tMDAgLyBkZXQsXG4gICAgICAvLyBtMTFcbiAgICAgICh0aGlzLm0xMCAqIHRoaXMubTAyIC0gdGhpcy5tMDAgKiB0aGlzLm0xMikgLyBkZXRcbiAgICAgIC8vIG0xMlxuICAgIF0pO1xuICB9XG4gIGdldCBhcnJheSgpIHtcbiAgICByZXR1cm4gW3RoaXMubTAwLCB0aGlzLm0wMSwgdGhpcy5tMDIsIHRoaXMubTEwLCB0aGlzLm0xMSwgdGhpcy5tMTIsIDAsIDAsIDFdO1xuICB9XG4gIGdldCBmbG9hdDMyQXJyYXkoKSB7XG4gICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkodGhpcy5hcnJheSk7XG4gIH1cbiAgLy8gU3RhdGljXG4gIHN0YXRpYyBnZXQgaWRlbnRpdHkoKSB7XG4gICAgcmV0dXJuIG5ldyBfQWZmaW5lVHJhbnNmb3JtKFsxLCAwLCAwLCAwLCAxLCAwXSk7XG4gIH1cbiAgc3RhdGljIHJvdGF0ZSh0aGV0YSwgb3JpZ2luKSB7XG4gICAgY29uc3Qgcm90YXRpb24gPSBuZXcgX0FmZmluZVRyYW5zZm9ybShbTWF0aC5jb3ModGhldGEpLCAtTWF0aC5zaW4odGhldGEpLCAwLCBNYXRoLnNpbih0aGV0YSksIE1hdGguY29zKHRoZXRhKSwgMF0pO1xuICAgIGlmIChvcmlnaW4gJiYgKG9yaWdpbi54ICE9PSAwIHx8IG9yaWdpbi55ICE9PSAwKSkge1xuICAgICAgcmV0dXJuIF9BZmZpbmVUcmFuc2Zvcm0ubXVsdGlwbHkoXG4gICAgICAgIF9BZmZpbmVUcmFuc2Zvcm0udHJhbnNsYXRlKG9yaWdpbi54LCBvcmlnaW4ueSksXG4gICAgICAgIHJvdGF0aW9uLFxuICAgICAgICBfQWZmaW5lVHJhbnNmb3JtLnRyYW5zbGF0ZSgtb3JpZ2luLngsIC1vcmlnaW4ueSlcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiByb3RhdGlvbjtcbiAgfVxuICBzdGF0aWMgc2NhbGUoc3gsIHN5ID0gc3gsIG9yaWdpbiA9IHsgeDogMCwgeTogMCB9KSB7XG4gICAgY29uc3Qgc2NhbGUgPSBuZXcgX0FmZmluZVRyYW5zZm9ybShbc3gsIDAsIDAsIDAsIHN5LCAwXSk7XG4gICAgaWYgKG9yaWdpbi54ICE9PSAwIHx8IG9yaWdpbi55ICE9PSAwKSB7XG4gICAgICByZXR1cm4gX0FmZmluZVRyYW5zZm9ybS5tdWx0aXBseShcbiAgICAgICAgX0FmZmluZVRyYW5zZm9ybS50cmFuc2xhdGUob3JpZ2luLngsIG9yaWdpbi55KSxcbiAgICAgICAgc2NhbGUsXG4gICAgICAgIF9BZmZpbmVUcmFuc2Zvcm0udHJhbnNsYXRlKC1vcmlnaW4ueCwgLW9yaWdpbi55KVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHNjYWxlO1xuICB9XG4gIHN0YXRpYyB0cmFuc2xhdGUodHgsIHR5KSB7XG4gICAgcmV0dXJuIG5ldyBfQWZmaW5lVHJhbnNmb3JtKFsxLCAwLCB0eCwgMCwgMSwgdHldKTtcbiAgfVxuICBzdGF0aWMgbXVsdGlwbHkoLi4uW2ZpcnN0LCAuLi5yZXN0XSkge1xuICAgIGlmICghZmlyc3QpIHJldHVybiBfQWZmaW5lVHJhbnNmb3JtLmlkZW50aXR5O1xuICAgIHJldHVybiByZXN0LnJlZHVjZSgocmVzdWx0LCBpdGVtKSA9PiByZXN1bHQucHJlcGVuZChpdGVtKSwgZmlyc3QpO1xuICB9XG4gIGdldCBhKCkge1xuICAgIHJldHVybiB0aGlzLm0wMDtcbiAgfVxuICBnZXQgYigpIHtcbiAgICByZXR1cm4gdGhpcy5tMTA7XG4gIH1cbiAgZ2V0IGMoKSB7XG4gICAgcmV0dXJuIHRoaXMubTAxO1xuICB9XG4gIGdldCBkKCkge1xuICAgIHJldHVybiB0aGlzLm0xMTtcbiAgfVxuICBnZXQgdHgoKSB7XG4gICAgcmV0dXJuIHRoaXMubTAyO1xuICB9XG4gIGdldCB0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5tMTI7XG4gIH1cbiAgZ2V0IHNjYWxlQ29tcG9uZW50cygpIHtcbiAgICByZXR1cm4geyB4OiB0aGlzLmEsIHk6IHRoaXMuZCB9O1xuICB9XG4gIGdldCB0cmFuc2xhdGlvbkNvbXBvbmVudHMoKSB7XG4gICAgcmV0dXJuIHsgeDogdGhpcy50eCwgeTogdGhpcy50eSB9O1xuICB9XG4gIGdldCBza2V3Q29tcG9uZW50cygpIHtcbiAgICByZXR1cm4geyB4OiB0aGlzLmMsIHk6IHRoaXMuYiB9O1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBgbWF0cml4KCR7dGhpcy5hfSwgJHt0aGlzLmJ9LCAke3RoaXMuY30sICR7dGhpcy5kfSwgJHt0aGlzLnR4fSwgJHt0aGlzLnR5fSlgO1xuICB9XG59O1xuXG4vLyBzcmMvYWxpZ24udHNcbmZ1bmN0aW9uIGhBbGlnbihhLCByZWYsIGgpIHtcbiAgbGV0IHggPSByZWYubWluWDtcbiAgaWYgKGggPT09IFwibGVmdC1pbnNpZGVcIikgeCA9IHJlZi5taW5YO1xuICBpZiAoaCA9PT0gXCJsZWZ0LW91dHNpZGVcIikgeCA9IHJlZi5taW5YIC0gcmVmLndpZHRoO1xuICBpZiAoaCA9PT0gXCJyaWdodC1pbnNpZGVcIikgeCA9IHJlZi5tYXhYIC0gcmVmLndpZHRoO1xuICBpZiAoaCA9PT0gXCJyaWdodC1vdXRzaWRlXCIpIHggPSByZWYubWF4WDtcbiAgaWYgKGggPT09IFwiY2VudGVyXCIpIHggPSByZWYubWlkWCAtIHJlZi53aWR0aCAvIDI7XG4gIHJldHVybiB7IC4uLmEsIHggfTtcbn1cbmZ1bmN0aW9uIHZBbGlnbihhLCByZWYsIHYpIHtcbiAgbGV0IHkgPSByZWYubWluWTtcbiAgaWYgKHYgPT09IFwidG9wLWluc2lkZVwiKSB5ID0gcmVmLm1pblk7XG4gIGlmICh2ID09PSBcInRvcC1vdXRzaWRlXCIpIHkgPSByZWYubWluWSAtIGEuaGVpZ2h0O1xuICBpZiAodiA9PT0gXCJib3R0b20taW5zaWRlXCIpIHkgPSByZWYubWF4WSAtIGEuaGVpZ2h0O1xuICBpZiAodiA9PT0gXCJib3R0b20tb3V0c2lkZVwiKSB5ID0gcmVmLm1heFk7XG4gIGlmICh2ID09PSBcImNlbnRlclwiKSB5ID0gcmVmLm1pZFkgLSBhLmhlaWdodCAvIDI7XG4gIHJldHVybiB7IC4uLmEsIHkgfTtcbn1cbmZ1bmN0aW9uIGFsaWduUmVjdChhLCByZWYsIG9wdGlvbnMpIHtcbiAgY29uc3QgeyBoLCB2IH0gPSBvcHRpb25zO1xuICByZXR1cm4gdkFsaWduKGhBbGlnbihhLCByZWYsIGgpLCByZWYsIHYpO1xufVxuXG4vLyBzcmMvYW5nbGUudHNcbmZ1bmN0aW9uIGdldFBvaW50QW5nbGUocmVjdCwgcG9pbnQsIHJlZmVyZW5jZSA9IHJlY3QuY2VudGVyKSB7XG4gIGNvbnN0IHggPSBwb2ludC54IC0gcmVmZXJlbmNlLng7XG4gIGNvbnN0IHkgPSBwb2ludC55IC0gcmVmZXJlbmNlLnk7XG4gIGNvbnN0IGRlZyA9IE1hdGguYXRhbjIoeCwgeSkgKiAoMTgwIC8gTWF0aC5QSSkgKyAxODA7XG4gIHJldHVybiAzNjAgLSBkZWc7XG59XG5cbi8vIHNyYy9jbGFtcC50c1xudmFyIGNsYW1wID0gKHZhbHVlLCBtaW4zLCBtYXgyKSA9PiBNYXRoLm1pbihNYXRoLm1heCh2YWx1ZSwgbWluMyksIG1heDIpO1xudmFyIGNsYW1wUG9pbnQgPSAocG9zaXRpb24sIHNpemUsIGJvdW5kYXJ5UmVjdCkgPT4ge1xuICBjb25zdCB4ID0gY2xhbXAocG9zaXRpb24ueCwgYm91bmRhcnlSZWN0LngsIGJvdW5kYXJ5UmVjdC54ICsgYm91bmRhcnlSZWN0LndpZHRoIC0gc2l6ZS53aWR0aCk7XG4gIGNvbnN0IHkgPSBjbGFtcChwb3NpdGlvbi55LCBib3VuZGFyeVJlY3QueSwgYm91bmRhcnlSZWN0LnkgKyBib3VuZGFyeVJlY3QuaGVpZ2h0IC0gc2l6ZS5oZWlnaHQpO1xuICByZXR1cm4geyB4LCB5IH07XG59O1xudmFyIGRlZmF1bHRNaW5TaXplID0ge1xuICB3aWR0aDogMCxcbiAgaGVpZ2h0OiAwXG59O1xudmFyIGRlZmF1bHRNYXhTaXplID0ge1xuICB3aWR0aDogSW5maW5pdHksXG4gIGhlaWdodDogSW5maW5pdHlcbn07XG52YXIgY2xhbXBTaXplID0gKHNpemUsIG1pblNpemUgPSBkZWZhdWx0TWluU2l6ZSwgbWF4U2l6ZSA9IGRlZmF1bHRNYXhTaXplKSA9PiB7XG4gIHJldHVybiB7XG4gICAgd2lkdGg6IE1hdGgubWluKE1hdGgubWF4KHNpemUud2lkdGgsIG1pblNpemUud2lkdGgpLCBtYXhTaXplLndpZHRoKSxcbiAgICBoZWlnaHQ6IE1hdGgubWluKE1hdGgubWF4KHNpemUuaGVpZ2h0LCBtaW5TaXplLmhlaWdodCksIG1heFNpemUuaGVpZ2h0KVxuICB9O1xufTtcblxuLy8gc3JjL3JlY3QudHNcbnZhciBjcmVhdGVQb2ludCA9ICh4LCB5KSA9PiAoeyB4LCB5IH0pO1xudmFyIHN1YnRyYWN0UG9pbnRzID0gKGEsIGIpID0+IHtcbiAgaWYgKCFiKSByZXR1cm4gYTtcbiAgcmV0dXJuIGNyZWF0ZVBvaW50KGEueCAtIGIueCwgYS55IC0gYi55KTtcbn07XG52YXIgYWRkUG9pbnRzID0gKGEsIGIpID0+IGNyZWF0ZVBvaW50KGEueCArIGIueCwgYS55ICsgYi55KTtcbmZ1bmN0aW9uIGlzUG9pbnQodikge1xuICByZXR1cm4gUmVmbGVjdC5oYXModiwgXCJ4XCIpICYmIFJlZmxlY3QuaGFzKHYsIFwieVwiKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJlY3Qocikge1xuICBjb25zdCB7IHgsIHksIHdpZHRoLCBoZWlnaHQgfSA9IHI7XG4gIGNvbnN0IG1pZFggPSB4ICsgd2lkdGggLyAyO1xuICBjb25zdCBtaWRZID0geSArIGhlaWdodCAvIDI7XG4gIHJldHVybiB7XG4gICAgeCxcbiAgICB5LFxuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICBtaW5YOiB4LFxuICAgIG1pblk6IHksXG4gICAgbWF4WDogeCArIHdpZHRoLFxuICAgIG1heFk6IHkgKyBoZWlnaHQsXG4gICAgbWlkWCxcbiAgICBtaWRZLFxuICAgIGNlbnRlcjogY3JlYXRlUG9pbnQobWlkWCwgbWlkWSlcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzUmVjdCh2KSB7XG4gIHJldHVybiBSZWZsZWN0Lmhhcyh2LCBcInhcIikgJiYgUmVmbGVjdC5oYXModiwgXCJ5XCIpICYmIFJlZmxlY3QuaGFzKHYsIFwid2lkdGhcIikgJiYgUmVmbGVjdC5oYXModiwgXCJoZWlnaHRcIik7XG59XG5mdW5jdGlvbiBnZXRSZWN0Q2VudGVycyh2KSB7XG4gIGNvbnN0IHRvcCA9IGNyZWF0ZVBvaW50KHYubWlkWCwgdi5taW5ZKTtcbiAgY29uc3QgcmlnaHQgPSBjcmVhdGVQb2ludCh2Lm1heFgsIHYubWlkWSk7XG4gIGNvbnN0IGJvdHRvbSA9IGNyZWF0ZVBvaW50KHYubWlkWCwgdi5tYXhZKTtcbiAgY29uc3QgbGVmdCA9IGNyZWF0ZVBvaW50KHYubWluWCwgdi5taWRZKTtcbiAgcmV0dXJuIHsgdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0IH07XG59XG5mdW5jdGlvbiBnZXRSZWN0Q29ybmVycyh2KSB7XG4gIGNvbnN0IHRvcCA9IGNyZWF0ZVBvaW50KHYubWluWCwgdi5taW5ZKTtcbiAgY29uc3QgcmlnaHQgPSBjcmVhdGVQb2ludCh2Lm1heFgsIHYubWluWSk7XG4gIGNvbnN0IGJvdHRvbSA9IGNyZWF0ZVBvaW50KHYubWF4WCwgdi5tYXhZKTtcbiAgY29uc3QgbGVmdCA9IGNyZWF0ZVBvaW50KHYubWluWCwgdi5tYXhZKTtcbiAgcmV0dXJuIHsgdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0IH07XG59XG5mdW5jdGlvbiBnZXRSZWN0RWRnZXModikge1xuICBjb25zdCBjID0gZ2V0UmVjdENvcm5lcnModik7XG4gIGNvbnN0IHRvcCA9IFtjLnRvcCwgYy5yaWdodF07XG4gIGNvbnN0IHJpZ2h0ID0gW2MucmlnaHQsIGMuYm90dG9tXTtcbiAgY29uc3QgYm90dG9tID0gW2MubGVmdCwgYy5ib3R0b21dO1xuICBjb25zdCBsZWZ0ID0gW2MudG9wLCBjLmxlZnRdO1xuICByZXR1cm4geyB0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQgfTtcbn1cblxuLy8gc3JjL2ludGVyc2VjdGlvbi50c1xuZnVuY3Rpb24gaW50ZXJzZWN0cyhhLCBiKSB7XG4gIHJldHVybiBhLnggPCBiLm1heFggJiYgYS55IDwgYi5tYXhZICYmIGEubWF4WCA+IGIueCAmJiBhLm1heFkgPiBiLnk7XG59XG5mdW5jdGlvbiBpbnRlcnNlY3Rpb24oYSwgYikge1xuICBjb25zdCB4ID0gTWF0aC5tYXgoYS54LCBiLngpO1xuICBjb25zdCB5ID0gTWF0aC5tYXgoYS55LCBiLnkpO1xuICBjb25zdCB4MiA9IE1hdGgubWluKGEueCArIGEud2lkdGgsIGIueCArIGIud2lkdGgpO1xuICBjb25zdCB5MiA9IE1hdGgubWluKGEueSArIGEuaGVpZ2h0LCBiLnkgKyBiLmhlaWdodCk7XG4gIHJldHVybiBjcmVhdGVSZWN0KHsgeCwgeSwgd2lkdGg6IHgyIC0geCwgaGVpZ2h0OiB5MiAtIHkgfSk7XG59XG5mdW5jdGlvbiBjb2xsaXNpb25zKGEsIGIpIHtcbiAgcmV0dXJuIHtcbiAgICB0b3A6IGEubWluWSA8PSBiLm1pblksXG4gICAgcmlnaHQ6IGEubWF4WCA+PSBiLm1heFgsXG4gICAgYm90dG9tOiBhLm1heFkgPj0gYi5tYXhZLFxuICAgIGxlZnQ6IGEubWluWCA8PSBiLm1pblhcbiAgfTtcbn1cblxuLy8gc3JjL2Rpc3RhbmNlLnRzXG5mdW5jdGlvbiBkaXN0YW5jZShhLCBiID0geyB4OiAwLCB5OiAwIH0pIHtcbiAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhhLnggLSBiLngsIDIpICsgTWF0aC5wb3coYS55IC0gYi55LCAyKSk7XG59XG5mdW5jdGlvbiBkaXN0YW5jZUZyb21Qb2ludChyLCBwKSB7XG4gIGxldCB4ID0gMDtcbiAgbGV0IHkgPSAwO1xuICBpZiAocC54IDwgci54KSB4ID0gci54IC0gcC54O1xuICBlbHNlIGlmIChwLnggPiByLm1heFgpIHggPSBwLnggLSByLm1heFg7XG4gIGlmIChwLnkgPCByLnkpIHkgPSByLnkgLSBwLnk7XG4gIGVsc2UgaWYgKHAueSA+IHIubWF4WSkgeSA9IHAueSAtIHIubWF4WTtcbiAgcmV0dXJuIHsgeCwgeSwgdmFsdWU6IGRpc3RhbmNlKHsgeCwgeSB9KSB9O1xufVxuZnVuY3Rpb24gZGlzdGFuY2VGcm9tUmVjdChhLCBiKSB7XG4gIGlmIChpbnRlcnNlY3RzKGEsIGIpKSByZXR1cm4geyB4OiAwLCB5OiAwLCB2YWx1ZTogMCB9O1xuICBjb25zdCBsZWZ0ID0gYS54IDwgYi54ID8gYSA6IGI7XG4gIGNvbnN0IHJpZ2h0ID0gYi54IDwgYS54ID8gYSA6IGI7XG4gIGNvbnN0IHVwcGVyID0gYS55IDwgYi55ID8gYSA6IGI7XG4gIGNvbnN0IGxvd2VyID0gYi55IDwgYS55ID8gYSA6IGI7XG4gIGxldCB4ID0gbGVmdC54ID09PSByaWdodC54ID8gMCA6IHJpZ2h0LnggLSBsZWZ0Lm1heFg7XG4gIHggPSBNYXRoLm1heCgwLCB4KTtcbiAgbGV0IHkgPSB1cHBlci55ID09PSBsb3dlci55ID8gMCA6IGxvd2VyLnkgLSB1cHBlci5tYXhZO1xuICB5ID0gTWF0aC5tYXgoMCwgeSk7XG4gIHJldHVybiB7IHgsIHksIHZhbHVlOiBkaXN0YW5jZSh7IHgsIHkgfSkgfTtcbn1cbmZ1bmN0aW9uIGRpc3RhbmNlQnR3RWRnZXMoYSwgYikge1xuICByZXR1cm4ge1xuICAgIGxlZnQ6IGIueCAtIGEueCxcbiAgICB0b3A6IGIueSAtIGEueSxcbiAgICByaWdodDogYS5tYXhYIC0gYi5tYXhYLFxuICAgIGJvdHRvbTogYS5tYXhZIC0gYi5tYXhZXG4gIH07XG59XG5cbi8vIHNyYy9jbG9zZXN0LnRzXG5mdW5jdGlvbiBjbG9zZXN0KC4uLnB0cykge1xuICByZXR1cm4gKGEpID0+IHtcbiAgICBjb25zdCBkcyA9IHB0cy5tYXAoKGIpID0+IGRpc3RhbmNlKGIsIGEpKTtcbiAgICBjb25zdCBjID0gTWF0aC5taW4uYXBwbHkoTWF0aCwgZHMpO1xuICAgIHJldHVybiBwdHNbZHMuaW5kZXhPZihjKV07XG4gIH07XG59XG5mdW5jdGlvbiBjbG9zZXN0U2lkZVRvUmVjdChyZWYsIHIpIHtcbiAgaWYgKHIubWF4WCA8PSByZWYubWluWCkgcmV0dXJuIFwibGVmdFwiO1xuICBpZiAoci5taW5YID49IHJlZi5tYXhYKSByZXR1cm4gXCJyaWdodFwiO1xuICBpZiAoci5tYXhZIDw9IHJlZi5taW5ZKSByZXR1cm4gXCJ0b3BcIjtcbiAgaWYgKHIubWluWSA+PSByZWYubWF4WSkgcmV0dXJuIFwiYm90dG9tXCI7XG4gIHJldHVybiBcImxlZnRcIjtcbn1cbmZ1bmN0aW9uIGNsb3Nlc3RTaWRlVG9Qb2ludChyZWYsIHApIHtcbiAgY29uc3QgeyB4LCB5IH0gPSBwO1xuICBjb25zdCBkbCA9IHggLSByZWYubWluWDtcbiAgY29uc3QgZHIgPSByZWYubWF4WCAtIHg7XG4gIGNvbnN0IGR0ID0geSAtIHJlZi5taW5ZO1xuICBjb25zdCBkYiA9IHJlZi5tYXhZIC0geTtcbiAgbGV0IGNsb3Nlc3QyID0gZGw7XG4gIGxldCBzaWRlID0gXCJsZWZ0XCI7XG4gIGlmIChkciA8IGNsb3Nlc3QyKSB7XG4gICAgY2xvc2VzdDIgPSBkcjtcbiAgICBzaWRlID0gXCJyaWdodFwiO1xuICB9XG4gIGlmIChkdCA8IGNsb3Nlc3QyKSB7XG4gICAgY2xvc2VzdDIgPSBkdDtcbiAgICBzaWRlID0gXCJ0b3BcIjtcbiAgfVxuICBpZiAoZGIgPCBjbG9zZXN0Mikge1xuICAgIHNpZGUgPSBcImJvdHRvbVwiO1xuICB9XG4gIHJldHVybiBzaWRlO1xufVxuXG4vLyBzcmMvY29uc3RyYWluLnRzXG52YXIgY29uc3RyYWluUmVjdCA9IChyZWN0LCBib3VuZGFyeSkgPT4ge1xuICBjb25zdCBsZWZ0ID0gTWF0aC5tYXgoYm91bmRhcnkueCwgTWF0aC5taW4ocmVjdC54LCBib3VuZGFyeS54ICsgYm91bmRhcnkud2lkdGggLSByZWN0LndpZHRoKSk7XG4gIGNvbnN0IHRvcCA9IE1hdGgubWF4KGJvdW5kYXJ5LnksIE1hdGgubWluKHJlY3QueSwgYm91bmRhcnkueSArIGJvdW5kYXJ5LmhlaWdodCAtIHJlY3QuaGVpZ2h0KSk7XG4gIHJldHVybiB7XG4gICAgeDogbGVmdCxcbiAgICB5OiB0b3AsXG4gICAgd2lkdGg6IE1hdGgubWluKHJlY3Qud2lkdGgsIGJvdW5kYXJ5LndpZHRoKSxcbiAgICBoZWlnaHQ6IE1hdGgubWluKHJlY3QuaGVpZ2h0LCBib3VuZGFyeS5oZWlnaHQpXG4gIH07XG59O1xuXG4vLyBzcmMvY29udGFpbnMudHNcbmZ1bmN0aW9uIGNvbnRhaW5zUG9pbnQociwgcCkge1xuICByZXR1cm4gci5taW5YIDw9IHAueCAmJiBwLnggPD0gci5tYXhYICYmIHIubWluWSA8PSBwLnkgJiYgcC55IDw9IHIubWF4WTtcbn1cbmZ1bmN0aW9uIGNvbnRhaW5zUmVjdChhLCBiKSB7XG4gIHJldHVybiBPYmplY3QudmFsdWVzKGdldFJlY3RDb3JuZXJzKGIpKS5ldmVyeSgoYykgPT4gY29udGFpbnNQb2ludChhLCBjKSk7XG59XG5mdW5jdGlvbiBjb250YWlucyhyLCB2KSB7XG4gIHJldHVybiBpc1JlY3QodikgPyBjb250YWluc1JlY3QociwgdikgOiBjb250YWluc1BvaW50KHIsIHYpO1xufVxuXG4vLyBzcmMvZXF1YWxpdHkudHNcbnZhciBpc1NpemVFcXVhbCA9IChhLCBiKSA9PiB7XG4gIHJldHVybiBhLndpZHRoID09PSBiPy53aWR0aCAmJiBhLmhlaWdodCA9PT0gYj8uaGVpZ2h0O1xufTtcbnZhciBpc1BvaW50RXF1YWwgPSAoYSwgYikgPT4ge1xuICByZXR1cm4gYS54ID09PSBiPy54ICYmIGEueSA9PT0gYj8ueTtcbn07XG52YXIgaXNSZWN0RXF1YWwgPSAoYSwgYikgPT4ge1xuICByZXR1cm4gaXNQb2ludEVxdWFsKGEsIGIpICYmIGlzU2l6ZUVxdWFsKGEsIGIpO1xufTtcblxuLy8gc3JjL2Zyb20tZWxlbWVudC50c1xudmFyIHN0eWxlQ2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIGdldENhY2hlQ29tcHV0ZWRTdHlsZShlbCkge1xuICBpZiAoIXN0eWxlQ2FjaGUuaGFzKGVsKSkge1xuICAgIGNvbnN0IHdpbiA9IGVsLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgfHwgd2luZG93O1xuICAgIHN0eWxlQ2FjaGUuc2V0KGVsLCB3aW4uZ2V0Q29tcHV0ZWRTdHlsZShlbCkpO1xuICB9XG4gIHJldHVybiBzdHlsZUNhY2hlLmdldChlbCk7XG59XG5mdW5jdGlvbiBnZXRFbGVtZW50UmVjdChlbCwgb3B0cyA9IHt9KSB7XG4gIHJldHVybiBjcmVhdGVSZWN0KGdldENsaWVudFJlY3QoZWwsIG9wdHMpKTtcbn1cbmZ1bmN0aW9uIGdldENsaWVudFJlY3QoZWwsIG9wdHMgPSB7fSkge1xuICBjb25zdCB7IGV4Y2x1ZGVTY3JvbGxiYXIgPSBmYWxzZSwgZXhjbHVkZUJvcmRlcnMgPSBmYWxzZSB9ID0gb3B0cztcbiAgY29uc3QgeyB4LCB5LCB3aWR0aCwgaGVpZ2h0IH0gPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgY29uc3QgciA9IHsgeCwgeSwgd2lkdGgsIGhlaWdodCB9O1xuICBjb25zdCBzdHlsZSA9IGdldENhY2hlQ29tcHV0ZWRTdHlsZShlbCk7XG4gIGNvbnN0IHsgYm9yZGVyTGVmdFdpZHRoLCBib3JkZXJUb3BXaWR0aCwgYm9yZGVyUmlnaHRXaWR0aCwgYm9yZGVyQm90dG9tV2lkdGggfSA9IHN0eWxlO1xuICBjb25zdCBib3JkZXJYV2lkdGggPSBzdW0oYm9yZGVyTGVmdFdpZHRoLCBib3JkZXJSaWdodFdpZHRoKTtcbiAgY29uc3QgYm9yZGVyWVdpZHRoID0gc3VtKGJvcmRlclRvcFdpZHRoLCBib3JkZXJCb3R0b21XaWR0aCk7XG4gIGlmIChleGNsdWRlQm9yZGVycykge1xuICAgIHIud2lkdGggLT0gYm9yZGVyWFdpZHRoO1xuICAgIHIuaGVpZ2h0IC09IGJvcmRlcllXaWR0aDtcbiAgICByLnggKz0gcHgoYm9yZGVyTGVmdFdpZHRoKTtcbiAgICByLnkgKz0gcHgoYm9yZGVyVG9wV2lkdGgpO1xuICB9XG4gIGlmIChleGNsdWRlU2Nyb2xsYmFyKSB7XG4gICAgY29uc3Qgc2Nyb2xsYmFyV2lkdGggPSBlbC5vZmZzZXRXaWR0aCAtIGVsLmNsaWVudFdpZHRoIC0gYm9yZGVyWFdpZHRoO1xuICAgIGNvbnN0IHNjcm9sbGJhckhlaWdodCA9IGVsLm9mZnNldEhlaWdodCAtIGVsLmNsaWVudEhlaWdodCAtIGJvcmRlcllXaWR0aDtcbiAgICByLndpZHRoIC09IHNjcm9sbGJhcldpZHRoO1xuICAgIHIuaGVpZ2h0IC09IHNjcm9sbGJhckhlaWdodDtcbiAgfVxuICByZXR1cm4gcjtcbn1cbnZhciBweCA9ICh2KSA9PiBwYXJzZUZsb2F0KHYucmVwbGFjZShcInB4XCIsIFwiXCIpKTtcbnZhciBzdW0gPSAoLi4udmFscykgPT4gdmFscy5yZWR1Y2UoKHN1bTIsIHYpID0+IHN1bTIgKyAodiA/IHB4KHYpIDogMCksIDApO1xuXG4vLyBzcmMvZnJvbS1wb2ludHMudHNcbmZ1bmN0aW9uIGdldFJlY3RGcm9tUG9pbnRzKC4uLnB0cykge1xuICBjb25zdCB4cyA9IHB0cy5tYXAoKHApID0+IHAueCk7XG4gIGNvbnN0IHlzID0gcHRzLm1hcCgocCkgPT4gcC55KTtcbiAgY29uc3QgeCA9IE1hdGgubWluKC4uLnhzKTtcbiAgY29uc3QgeSA9IE1hdGgubWluKC4uLnlzKTtcbiAgY29uc3Qgd2lkdGggPSBNYXRoLm1heCguLi54cykgLSB4O1xuICBjb25zdCBoZWlnaHQgPSBNYXRoLm1heCguLi55cykgLSB5O1xuICByZXR1cm4gY3JlYXRlUmVjdCh7IHgsIHksIHdpZHRoLCBoZWlnaHQgfSk7XG59XG5cbi8vIHNyYy91bmlvbi50c1xudmFyIHsgbWluLCBtYXggfSA9IE1hdGg7XG5mdW5jdGlvbiB1bmlvbiguLi5ycykge1xuICBjb25zdCBwTWluID0ge1xuICAgIHg6IG1pbiguLi5ycy5tYXAoKHIpID0+IHIubWluWCkpLFxuICAgIHk6IG1pbiguLi5ycy5tYXAoKHIpID0+IHIubWluWSkpXG4gIH07XG4gIGNvbnN0IHBNYXggPSB7XG4gICAgeDogbWF4KC4uLnJzLm1hcCgocikgPT4gci5tYXhYKSksXG4gICAgeTogbWF4KC4uLnJzLm1hcCgocikgPT4gci5tYXhZKSlcbiAgfTtcbiAgcmV0dXJuIGdldFJlY3RGcm9tUG9pbnRzKHBNaW4sIHBNYXgpO1xufVxuXG4vLyBzcmMvZnJvbS1yYW5nZS50c1xuZnVuY3Rpb24gZnJvbVJhbmdlKHJhbmdlKSB7XG4gIGxldCBycyA9IFtdO1xuICBjb25zdCByZWN0cyA9IEFycmF5LmZyb20ocmFuZ2UuZ2V0Q2xpZW50UmVjdHMoKSk7XG4gIGlmIChyZWN0cy5sZW5ndGgpIHtcbiAgICBycyA9IHJzLmNvbmNhdChyZWN0cy5tYXAoY3JlYXRlUmVjdCkpO1xuICAgIHJldHVybiB1bmlvbi5hcHBseSh2b2lkIDAsIHJzKTtcbiAgfVxuICBsZXQgc3RhcnQgPSByYW5nZS5zdGFydENvbnRhaW5lcjtcbiAgaWYgKHN0YXJ0Lm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSkge1xuICAgIHN0YXJ0ID0gc3RhcnQucGFyZW50Tm9kZTtcbiAgfVxuICBpZiAoc3RhcnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgIGNvbnN0IHIgPSBnZXRFbGVtZW50UmVjdChzdGFydCk7XG4gICAgcnMucHVzaCh7IC4uLnIsIHg6IHIubWF4WCwgd2lkdGg6IDAgfSk7XG4gIH1cbiAgcmV0dXJuIHVuaW9uLmFwcGx5KHZvaWQgMCwgcnMpO1xufVxuXG4vLyBzcmMvZnJvbS1yb3RhdGlvbi50c1xuZnVuY3Rpb24gdG9SYWQoZCkge1xuICByZXR1cm4gZCAlIDM2MCAqIE1hdGguUEkgLyAxODA7XG59XG5mdW5jdGlvbiByb3RhdGUoYSwgZCwgYykge1xuICBjb25zdCByID0gdG9SYWQoZCk7XG4gIGNvbnN0IHNpbiA9IE1hdGguc2luKHIpO1xuICBjb25zdCBjb3MgPSBNYXRoLmNvcyhyKTtcbiAgY29uc3QgeCA9IGEueCAtIGMueDtcbiAgY29uc3QgeSA9IGEueSAtIGMueTtcbiAgcmV0dXJuIHtcbiAgICB4OiBjLnggKyB4ICogY29zIC0geSAqIHNpbixcbiAgICB5OiBjLnkgKyB4ICogc2luICsgeSAqIGNvc1xuICB9O1xufVxuZnVuY3Rpb24gZ2V0Um90YXRpb25SZWN0KHIsIGRlZykge1xuICBjb25zdCByciA9IE9iamVjdC52YWx1ZXMoZ2V0UmVjdENvcm5lcnMocikpLm1hcCgocCkgPT4gcm90YXRlKHAsIGRlZywgci5jZW50ZXIpKTtcbiAgY29uc3QgeHMgPSByci5tYXAoKHApID0+IHAueCk7XG4gIGNvbnN0IHlzID0gcnIubWFwKChwKSA9PiBwLnkpO1xuICBjb25zdCBtaW5YID0gTWF0aC5taW4oLi4ueHMpO1xuICBjb25zdCBtaW5ZID0gTWF0aC5taW4oLi4ueXMpO1xuICBjb25zdCBtYXhYID0gTWF0aC5tYXgoLi4ueHMpO1xuICBjb25zdCBtYXhZID0gTWF0aC5tYXgoLi4ueXMpO1xuICByZXR1cm4gY3JlYXRlUmVjdCh7XG4gICAgeDogbWluWCxcbiAgICB5OiBtaW5ZLFxuICAgIHdpZHRoOiBtYXhYIC0gbWluWCxcbiAgICBoZWlnaHQ6IG1heFkgLSBtaW5ZXG4gIH0pO1xufVxuXG4vLyBzcmMvZnJvbS13aW5kb3cudHNcbmZ1bmN0aW9uIGdldFdpbmRvd1JlY3Qod2luLCBvcHRzID0ge30pIHtcbiAgcmV0dXJuIGNyZWF0ZVJlY3QoZ2V0Vmlld3BvcnRSZWN0KHdpbiwgb3B0cykpO1xufVxuZnVuY3Rpb24gZ2V0Vmlld3BvcnRSZWN0KHdpbiwgb3B0cykge1xuICBjb25zdCB7IGV4Y2x1ZGVTY3JvbGxiYXIgPSBmYWxzZSB9ID0gb3B0cztcbiAgY29uc3QgeyBpbm5lcldpZHRoLCBpbm5lckhlaWdodCwgZG9jdW1lbnQ6IGRvYywgdmlzdWFsVmlld3BvcnQgfSA9IHdpbjtcbiAgY29uc3Qgd2lkdGggPSB2aXN1YWxWaWV3cG9ydD8ud2lkdGggfHwgaW5uZXJXaWR0aDtcbiAgY29uc3QgaGVpZ2h0ID0gdmlzdWFsVmlld3BvcnQ/LmhlaWdodCB8fCBpbm5lckhlaWdodDtcbiAgY29uc3QgcmVjdCA9IHsgeDogMCwgeTogMCwgd2lkdGgsIGhlaWdodCB9O1xuICBpZiAoZXhjbHVkZVNjcm9sbGJhcikge1xuICAgIGNvbnN0IHNjcm9sbGJhcldpZHRoID0gaW5uZXJXaWR0aCAtIGRvYy5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7XG4gICAgY29uc3Qgc2Nyb2xsYmFySGVpZ2h0ID0gaW5uZXJIZWlnaHQgLSBkb2MuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodDtcbiAgICByZWN0LndpZHRoIC09IHNjcm9sbGJhcldpZHRoO1xuICAgIHJlY3QuaGVpZ2h0IC09IHNjcm9sbGJhckhlaWdodDtcbiAgfVxuICByZXR1cm4gcmVjdDtcbn1cblxuLy8gc3JjL29wZXJhdGlvbnMudHNcbnZhciBpc1N5bW1ldHJpYyA9ICh2KSA9PiBcImR4XCIgaW4gdiB8fCBcImR5XCIgaW4gdjtcbmZ1bmN0aW9uIGluc2V0KHIsIGkpIHtcbiAgY29uc3QgdiA9IGlzU3ltbWV0cmljKGkpID8geyBsZWZ0OiBpLmR4LCByaWdodDogaS5keCwgdG9wOiBpLmR5LCBib3R0b206IGkuZHkgfSA6IGk7XG4gIGNvbnN0IHsgdG9wID0gMCwgcmlnaHQgPSAwLCBib3R0b20gPSAwLCBsZWZ0ID0gMCB9ID0gdjtcbiAgcmV0dXJuIGNyZWF0ZVJlY3Qoe1xuICAgIHg6IHIueCArIGxlZnQsXG4gICAgeTogci55ICsgdG9wLFxuICAgIHdpZHRoOiByLndpZHRoIC0gbGVmdCAtIHJpZ2h0LFxuICAgIGhlaWdodDogci5oZWlnaHQgLSB0b3AgLSBib3R0b21cbiAgfSk7XG59XG5mdW5jdGlvbiBleHBhbmQociwgdikge1xuICBjb25zdCB2YWx1ZSA9IHR5cGVvZiB2ID09PSBcIm51bWJlclwiID8geyBkeDogLXYsIGR5OiAtdiB9IDogdjtcbiAgcmV0dXJuIGluc2V0KHIsIHZhbHVlKTtcbn1cbmZ1bmN0aW9uIHNocmluayhyLCB2KSB7XG4gIGNvbnN0IHZhbHVlID0gdHlwZW9mIHYgPT09IFwibnVtYmVyXCIgPyB7IGR4OiAtdiwgZHk6IC12IH0gOiB2O1xuICByZXR1cm4gaW5zZXQociwgdmFsdWUpO1xufVxuZnVuY3Rpb24gc2hpZnQociwgbykge1xuICBjb25zdCB7IHggPSAwLCB5ID0gMCB9ID0gbztcbiAgcmV0dXJuIGNyZWF0ZVJlY3Qoe1xuICAgIHg6IHIueCArIHgsXG4gICAgeTogci55ICsgeSxcbiAgICB3aWR0aDogci53aWR0aCxcbiAgICBoZWlnaHQ6IHIuaGVpZ2h0XG4gIH0pO1xufVxuXG4vLyBzcmMvcG9seWdvbi50c1xuZnVuY3Rpb24gZ2V0RWxlbWVudFBvbHlnb24ocmVjdFZhbHVlLCBwbGFjZW1lbnQpIHtcbiAgY29uc3QgcmVjdCA9IGNyZWF0ZVJlY3QocmVjdFZhbHVlKTtcbiAgY29uc3QgeyB0b3AsIHJpZ2h0LCBsZWZ0LCBib3R0b20gfSA9IGdldFJlY3RDb3JuZXJzKHJlY3QpO1xuICBjb25zdCBbYmFzZV0gPSBwbGFjZW1lbnQuc3BsaXQoXCItXCIpO1xuICByZXR1cm4ge1xuICAgIHRvcDogW2xlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbV0sXG4gICAgcmlnaHQ6IFt0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnRdLFxuICAgIGJvdHRvbTogW3RvcCwgbGVmdCwgYm90dG9tLCByaWdodF0sXG4gICAgbGVmdDogW3JpZ2h0LCB0b3AsIGxlZnQsIGJvdHRvbV1cbiAgfVtiYXNlXTtcbn1cbmZ1bmN0aW9uIGlzUG9pbnRJblBvbHlnb24ocG9seWdvbiwgcG9pbnQpIHtcbiAgY29uc3QgeyB4LCB5IH0gPSBwb2ludDtcbiAgbGV0IGMgPSBmYWxzZTtcbiAgZm9yIChsZXQgaSA9IDAsIGogPSBwb2x5Z29uLmxlbmd0aCAtIDE7IGkgPCBwb2x5Z29uLmxlbmd0aDsgaiA9IGkrKykge1xuICAgIGNvbnN0IHhpID0gcG9seWdvbltpXS54O1xuICAgIGNvbnN0IHlpID0gcG9seWdvbltpXS55O1xuICAgIGNvbnN0IHhqID0gcG9seWdvbltqXS54O1xuICAgIGNvbnN0IHlqID0gcG9seWdvbltqXS55O1xuICAgIGlmICh5aSA+IHkgIT09IHlqID4geSAmJiB4IDwgKHhqIC0geGkpICogKHkgLSB5aSkgLyAoeWogLSB5aSkgKyB4aSkge1xuICAgICAgYyA9ICFjO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYztcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBvbHlnb25FbGVtZW50KCkge1xuICBjb25zdCBpZCA9IFwiZGVidWctcG9seWdvblwiO1xuICBjb25zdCBleGlzdGluZ1BvbHlnb24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCk7XG4gIGlmIChleGlzdGluZ1BvbHlnb24pIHtcbiAgICByZXR1cm4gZXhpc3RpbmdQb2x5Z29uO1xuICB9XG4gIGNvbnN0IHN2ZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwic3ZnXCIpO1xuICBPYmplY3QuYXNzaWduKHN2Zy5zdHlsZSwge1xuICAgIHRvcDogXCIwXCIsXG4gICAgbGVmdDogXCIwXCIsXG4gICAgd2lkdGg6IFwiMTAwJVwiLFxuICAgIGhlaWdodDogXCIxMDAlXCIsXG4gICAgb3BhY2l0eTogXCIwLjE1XCIsXG4gICAgcG9zaXRpb246IFwiZml4ZWRcIixcbiAgICBwb2ludGVyRXZlbnRzOiBcIm5vbmVcIixcbiAgICBmaWxsOiBcInJlZFwiXG4gIH0pO1xuICBjb25zdCBwb2x5Z29uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJwb2x5Z29uXCIpO1xuICBwb2x5Z29uLnNldEF0dHJpYnV0ZShcImlkXCIsIGlkKTtcbiAgcG9seWdvbi5zZXRBdHRyaWJ1dGUoXCJwb2ludHNcIiwgXCIwLDAgMCwwXCIpO1xuICBzdmcuYXBwZW5kQ2hpbGQocG9seWdvbik7XG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc3ZnKTtcbiAgcmV0dXJuIHBvbHlnb247XG59XG5mdW5jdGlvbiBkZWJ1Z1BvbHlnb24ocG9seWdvbikge1xuICBjb25zdCBlbCA9IGNyZWF0ZVBvbHlnb25FbGVtZW50KCk7XG4gIGNvbnN0IHBvaW50cyA9IHBvbHlnb24ubWFwKChwb2ludCkgPT4gYCR7cG9pbnQueH0sJHtwb2ludC55fWApLmpvaW4oXCIgXCIpO1xuICBlbC5zZXRBdHRyaWJ1dGUoXCJwb2ludHNcIiwgcG9pbnRzKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBlbC5yZW1vdmUoKTtcbiAgfTtcbn1cblxuLy8gc3JjL2NvbXBhc3MudHNcbnZhciBjb21wYXNzRGlyZWN0aW9uTWFwID0ge1xuICBuOiB7IHg6IDAuNSwgeTogMCB9LFxuICBuZTogeyB4OiAxLCB5OiAwIH0sXG4gIGU6IHsgeDogMSwgeTogMC41IH0sXG4gIHNlOiB7IHg6IDEsIHk6IDEgfSxcbiAgczogeyB4OiAwLjUsIHk6IDEgfSxcbiAgc3c6IHsgeDogMCwgeTogMSB9LFxuICB3OiB7IHg6IDAsIHk6IDAuNSB9LFxuICBudzogeyB4OiAwLCB5OiAwIH1cbn07XG52YXIgb3Bwb3NpdGVEaXJlY3Rpb25NYXAgPSB7XG4gIG46IFwic1wiLFxuICBuZTogXCJzd1wiLFxuICBlOiBcIndcIixcbiAgc2U6IFwibndcIixcbiAgczogXCJuXCIsXG4gIHN3OiBcIm5lXCIsXG4gIHc6IFwiZVwiLFxuICBudzogXCJzZVwiXG59O1xuXG4vLyBzcmMvcmVzaXplLnRzXG52YXIgeyBzaWduLCBhYnMsIG1pbjogbWluMiB9ID0gTWF0aDtcbmZ1bmN0aW9uIGdldFJlY3RFeHRlbnRQb2ludChyZWN0LCBkaXJlY3Rpb24pIHtcbiAgY29uc3QgeyBtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZLCBtaWRYLCBtaWRZIH0gPSByZWN0O1xuICBjb25zdCB4ID0gZGlyZWN0aW9uLmluY2x1ZGVzKFwid1wiKSA/IG1pblggOiBkaXJlY3Rpb24uaW5jbHVkZXMoXCJlXCIpID8gbWF4WCA6IG1pZFg7XG4gIGNvbnN0IHkgPSBkaXJlY3Rpb24uaW5jbHVkZXMoXCJuXCIpID8gbWluWSA6IGRpcmVjdGlvbi5pbmNsdWRlcyhcInNcIikgPyBtYXhZIDogbWlkWTtcbiAgcmV0dXJuIHsgeCwgeSB9O1xufVxuZnVuY3Rpb24gZ2V0T3Bwb3NpdGVEaXJlY3Rpb24oZGlyZWN0aW9uKSB7XG4gIHJldHVybiBvcHBvc2l0ZURpcmVjdGlvbk1hcFtkaXJlY3Rpb25dO1xufVxuZnVuY3Rpb24gcmVzaXplUmVjdChyZWN0LCBvZmZzZXQsIGRpcmVjdGlvbiwgb3B0cykge1xuICBjb25zdCB7IHNjYWxpbmdPcmlnaW5Nb2RlLCBsb2NrQXNwZWN0UmF0aW8gfSA9IG9wdHM7XG4gIGNvbnN0IGV4dGVudCA9IGdldFJlY3RFeHRlbnRQb2ludChyZWN0LCBkaXJlY3Rpb24pO1xuICBjb25zdCBvcHBvc2l0ZURpcmVjdGlvbiA9IGdldE9wcG9zaXRlRGlyZWN0aW9uKGRpcmVjdGlvbik7XG4gIGNvbnN0IG9wcG9zaXRlRXh0ZW50ID0gZ2V0UmVjdEV4dGVudFBvaW50KHJlY3QsIG9wcG9zaXRlRGlyZWN0aW9uKTtcbiAgaWYgKHNjYWxpbmdPcmlnaW5Nb2RlID09PSBcImNlbnRlclwiKSB7XG4gICAgb2Zmc2V0ID0geyB4OiBvZmZzZXQueCAqIDIsIHk6IG9mZnNldC55ICogMiB9O1xuICB9XG4gIGNvbnN0IG5ld0V4dGVudCA9IHtcbiAgICB4OiBleHRlbnQueCArIG9mZnNldC54LFxuICAgIHk6IGV4dGVudC55ICsgb2Zmc2V0LnlcbiAgfTtcbiAgY29uc3QgbXVsdGlwbGllciA9IHtcbiAgICB4OiBjb21wYXNzRGlyZWN0aW9uTWFwW2RpcmVjdGlvbl0ueCAqIDIgLSAxLFxuICAgIHk6IGNvbXBhc3NEaXJlY3Rpb25NYXBbZGlyZWN0aW9uXS55ICogMiAtIDFcbiAgfTtcbiAgY29uc3QgbmV3U2l6ZSA9IHtcbiAgICB3aWR0aDogbmV3RXh0ZW50LnggLSBvcHBvc2l0ZUV4dGVudC54LFxuICAgIGhlaWdodDogbmV3RXh0ZW50LnkgLSBvcHBvc2l0ZUV4dGVudC55XG4gIH07XG4gIGNvbnN0IHNjYWxlWCA9IG11bHRpcGxpZXIueCAqIG5ld1NpemUud2lkdGggLyByZWN0LndpZHRoO1xuICBjb25zdCBzY2FsZVkgPSBtdWx0aXBsaWVyLnkgKiBuZXdTaXplLmhlaWdodCAvIHJlY3QuaGVpZ2h0O1xuICBjb25zdCBsYXJnZXN0TWFnbml0dWRlID0gYWJzKHNjYWxlWCkgPiBhYnMoc2NhbGVZKSA/IHNjYWxlWCA6IHNjYWxlWTtcbiAgY29uc3Qgc2NhbGUgPSBsb2NrQXNwZWN0UmF0aW8gPyB7IHg6IGxhcmdlc3RNYWduaXR1ZGUsIHk6IGxhcmdlc3RNYWduaXR1ZGUgfSA6IHtcbiAgICB4OiBleHRlbnQueCA9PT0gb3Bwb3NpdGVFeHRlbnQueCA/IDEgOiBzY2FsZVgsXG4gICAgeTogZXh0ZW50LnkgPT09IG9wcG9zaXRlRXh0ZW50LnkgPyAxIDogc2NhbGVZXG4gIH07XG4gIGlmIChleHRlbnQueSA9PT0gb3Bwb3NpdGVFeHRlbnQueSkge1xuICAgIHNjYWxlLnkgPSBhYnMoc2NhbGUueSk7XG4gIH0gZWxzZSBpZiAoc2lnbihzY2FsZS55KSAhPT0gc2lnbihzY2FsZVkpKSB7XG4gICAgc2NhbGUueSAqPSAtMTtcbiAgfVxuICBpZiAoZXh0ZW50LnggPT09IG9wcG9zaXRlRXh0ZW50LngpIHtcbiAgICBzY2FsZS54ID0gYWJzKHNjYWxlLngpO1xuICB9IGVsc2UgaWYgKHNpZ24oc2NhbGUueCkgIT09IHNpZ24oc2NhbGVYKSkge1xuICAgIHNjYWxlLnggKj0gLTE7XG4gIH1cbiAgc3dpdGNoIChzY2FsaW5nT3JpZ2luTW9kZSkge1xuICAgIGNhc2UgXCJleHRlbnRcIjpcbiAgICAgIHJldHVybiB0cmFuc2Zvcm1SZWN0KHJlY3QsIEFmZmluZVRyYW5zZm9ybS5zY2FsZShzY2FsZS54LCBzY2FsZS55LCBvcHBvc2l0ZUV4dGVudCksIGZhbHNlKTtcbiAgICBjYXNlIFwiY2VudGVyXCI6XG4gICAgICByZXR1cm4gdHJhbnNmb3JtUmVjdChcbiAgICAgICAgcmVjdCxcbiAgICAgICAgQWZmaW5lVHJhbnNmb3JtLnNjYWxlKHNjYWxlLngsIHNjYWxlLnksIHtcbiAgICAgICAgICB4OiByZWN0Lm1pZFgsXG4gICAgICAgICAgeTogcmVjdC5taWRZXG4gICAgICAgIH0pLFxuICAgICAgICBmYWxzZVxuICAgICAgKTtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlUmVjdEZyb21Qb2ludHMoaW5pdGlhbFBvaW50LCBmaW5hbFBvaW50LCBub3JtYWxpemVkID0gdHJ1ZSkge1xuICBpZiAobm9ybWFsaXplZCkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiBtaW4yKGZpbmFsUG9pbnQueCwgaW5pdGlhbFBvaW50LngpLFxuICAgICAgeTogbWluMihmaW5hbFBvaW50LnksIGluaXRpYWxQb2ludC55KSxcbiAgICAgIHdpZHRoOiBhYnMoZmluYWxQb2ludC54IC0gaW5pdGlhbFBvaW50LngpLFxuICAgICAgaGVpZ2h0OiBhYnMoZmluYWxQb2ludC55IC0gaW5pdGlhbFBvaW50LnkpXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHg6IGluaXRpYWxQb2ludC54LFxuICAgIHk6IGluaXRpYWxQb2ludC55LFxuICAgIHdpZHRoOiBmaW5hbFBvaW50LnggLSBpbml0aWFsUG9pbnQueCxcbiAgICBoZWlnaHQ6IGZpbmFsUG9pbnQueSAtIGluaXRpYWxQb2ludC55XG4gIH07XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm1SZWN0KHJlY3QsIHRyYW5zZm9ybSwgbm9ybWFsaXplZCA9IHRydWUpIHtcbiAgY29uc3QgcDEgPSB0cmFuc2Zvcm0uYXBwbHlUbyh7IHg6IHJlY3QubWluWCwgeTogcmVjdC5taW5ZIH0pO1xuICBjb25zdCBwMiA9IHRyYW5zZm9ybS5hcHBseVRvKHsgeDogcmVjdC5tYXhYLCB5OiByZWN0Lm1heFkgfSk7XG4gIHJldHVybiBjcmVhdGVSZWN0RnJvbVBvaW50cyhwMSwgcDIsIG5vcm1hbGl6ZWQpO1xufVxuXG5leHBvcnQgeyBBZmZpbmVUcmFuc2Zvcm0sIGFkZFBvaW50cywgYWxpZ25SZWN0LCBjbGFtcFBvaW50LCBjbGFtcFNpemUsIGNsb3Nlc3QsIGNsb3Nlc3RTaWRlVG9Qb2ludCwgY2xvc2VzdFNpZGVUb1JlY3QsIGNvbGxpc2lvbnMsIGNvbnN0cmFpblJlY3QsIGNvbnRhaW5zLCBjb250YWluc1BvaW50LCBjb250YWluc1JlY3QsIGNyZWF0ZVBvaW50LCBjcmVhdGVSZWN0LCBkZWJ1Z1BvbHlnb24sIGRpc3RhbmNlLCBkaXN0YW5jZUJ0d0VkZ2VzLCBkaXN0YW5jZUZyb21Qb2ludCwgZGlzdGFuY2VGcm9tUmVjdCwgZXhwYW5kLCBmcm9tUmFuZ2UsIGdldEVsZW1lbnRQb2x5Z29uLCBnZXRFbGVtZW50UmVjdCwgZ2V0UG9pbnRBbmdsZSwgZ2V0UmVjdENlbnRlcnMsIGdldFJlY3RDb3JuZXJzLCBnZXRSZWN0RWRnZXMsIGdldFJlY3RGcm9tUG9pbnRzLCBnZXRSb3RhdGlvblJlY3QsIGdldFZpZXdwb3J0UmVjdCwgZ2V0V2luZG93UmVjdCwgaW5zZXQsIGludGVyc2VjdGlvbiwgaW50ZXJzZWN0cywgaXNQb2ludCwgaXNQb2ludEVxdWFsLCBpc1BvaW50SW5Qb2x5Z29uLCBpc1JlY3QsIGlzUmVjdEVxdWFsLCBpc1NpemVFcXVhbCwgaXNTeW1tZXRyaWMsIHJlc2l6ZVJlY3QsIHJvdGF0ZSwgc2hpZnQsIHNocmluaywgc3VidHJhY3RQb2ludHMsIHRvUmFkLCB1bmlvbiB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@zag-js+rect-utils@1.21.7/node_modules/@zag-js/rect-utils/dist/index.mjs\n");

/***/ })

};
;