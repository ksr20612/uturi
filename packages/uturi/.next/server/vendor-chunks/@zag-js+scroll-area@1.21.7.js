"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@zag-js+scroll-area@1.21.7";
exports.ids = ["vendor-chunks/@zag-js+scroll-area@1.21.7"];
exports.modules = {

/***/ "(ssr)/../../node_modules/.pnpm/@zag-js+scroll-area@1.21.7/node_modules/@zag-js/scroll-area/dist/index.mjs":
/*!***********************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@zag-js+scroll-area@1.21.7/node_modules/@zag-js/scroll-area/dist/index.mjs ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   anatomy: () => (/* binding */ anatomy),\n/* harmony export */   connect: () => (/* binding */ connect),\n/* harmony export */   machine: () => (/* binding */ machine),\n/* harmony export */   props: () => (/* binding */ props),\n/* harmony export */   splitProps: () => (/* binding */ splitProps)\n/* harmony export */ });\n/* harmony import */ var _zag_js_anatomy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @zag-js/anatomy */ \"(ssr)/../../node_modules/.pnpm/@zag-js+anatomy@1.21.7/node_modules/@zag-js/anatomy/dist/index.mjs\");\n/* harmony import */ var _zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @zag-js/dom-query */ \"(ssr)/../../node_modules/.pnpm/@zag-js+dom-query@1.21.7/node_modules/@zag-js/dom-query/dist/index.mjs\");\n/* harmony import */ var _zag_js_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @zag-js/utils */ \"(ssr)/../../node_modules/.pnpm/@zag-js+utils@1.21.7/node_modules/@zag-js/utils/dist/index.mjs\");\n/* harmony import */ var _zag_js_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @zag-js/core */ \"(ssr)/../../node_modules/.pnpm/@zag-js+core@1.21.7/node_modules/@zag-js/core/dist/index.mjs\");\n/* harmony import */ var _zag_js_types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @zag-js/types */ \"(ssr)/../../node_modules/.pnpm/@zag-js+types@1.21.7/node_modules/@zag-js/types/dist/index.mjs\");\n\n\n\n\n\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nvar anatomy = (0,_zag_js_anatomy__WEBPACK_IMPORTED_MODULE_0__.createAnatomy)(\"scroll-area\").parts(\"root\", \"viewport\", \"content\", \"scrollbar\", \"thumb\", \"corner\");\nvar parts = anatomy.build();\nvar getRootId = (ctx) => ctx.ids?.root ?? `scroll-area-${ctx.id}`;\nvar getViewportId = (ctx) => ctx.ids?.viewport ?? `scroll-area-${ctx.id}:viewport`;\nvar getContentId = (ctx) => ctx.ids?.content ?? `scroll-area-${ctx.id}:content`;\nvar getRootEl = (ctx) => ctx.getById(getRootId(ctx));\nvar getViewportEl = (ctx) => ctx.getById(getViewportId(ctx));\nvar getContentEl = (ctx) => ctx.getById(getContentId(ctx));\nvar getScrollbarXEl = (ctx) => (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.query)(getRootEl(ctx), `[data-part=scrollbar][data-orientation=horizontal][data-ownedby=\"${getRootId(ctx)}\"]`);\nvar getScrollbarYEl = (ctx) => (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.query)(getRootEl(ctx), `[data-part=scrollbar][data-orientation=vertical][data-ownedby=\"${getRootId(ctx)}\"]`);\nvar getThumbXEl = (ctx) => (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.query)(getScrollbarXEl(ctx), `[data-part=thumb][data-orientation=horizontal][data-ownedby=\"${getRootId(ctx)}\"]`);\nvar getThumbYEl = (ctx) => (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.query)(getScrollbarYEl(ctx), `[data-part=thumb][data-orientation=vertical][data-ownedby=\"${getRootId(ctx)}\"]`);\nvar getCornerEl = (ctx) => (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.query)(getRootEl(ctx), `[data-part=corner][data-ownedby=\"${getRootId(ctx)}\"]`);\n\n// src/utils/scroll-progress.ts\nfunction getScrollProgress(element, scrollThreshold) {\n  if (!element) return EMPTY_SCROLL_PROGRESS;\n  let progressX = 0;\n  let progressY = 0;\n  const maxScrollX = element.scrollWidth - element.clientWidth;\n  if (maxScrollX > scrollThreshold) {\n    progressX = Math.min(1, Math.max(0, element.scrollLeft / maxScrollX));\n  }\n  const maxScrollY = element.scrollHeight - element.clientHeight;\n  if (maxScrollY > scrollThreshold) {\n    progressY = Math.min(1, Math.max(0, element.scrollTop / maxScrollY));\n  }\n  return { x: progressX, y: progressY };\n}\nvar EMPTY_SCROLL_PROGRESS = { x: 0, y: 0 };\n\n// src/utils/smooth-scroll.ts\nvar DURATION = 300;\nvar EASE_OUT_QUAD = (t) => t * (2 - t);\nfunction smoothScroll(node, options = {}) {\n  const { top, left, duration = DURATION, easing = EASE_OUT_QUAD, onComplete } = options;\n  if (!node) return;\n  const state = {\n    startTime: 0,\n    startScrollTop: node.scrollTop,\n    startScrollLeft: node.scrollLeft,\n    targetScrollTop: top ?? node.scrollTop,\n    targetScrollLeft: left ?? node.scrollLeft\n  };\n  let cancelled = false;\n  const cleanup = () => {\n    if (state.rafId) {\n      cancelAnimationFrame(state.rafId);\n      state.rafId = void 0;\n    }\n    cancelled = true;\n  };\n  const animate = (currentTime) => {\n    if (cancelled) return;\n    if (state.startTime === 0) {\n      state.startTime = currentTime;\n    }\n    const elapsed = currentTime - state.startTime;\n    const progress = Math.min(elapsed / duration, 1);\n    const easedProgress = easing(progress);\n    const deltaTop = state.targetScrollTop - state.startScrollTop;\n    const deltaLeft = state.targetScrollLeft - state.startScrollLeft;\n    node.scrollTop = state.startScrollTop + deltaTop * easedProgress;\n    node.scrollLeft = state.startScrollLeft + deltaLeft * easedProgress;\n    if (progress < 1) {\n      state.rafId = requestAnimationFrame(animate);\n    } else {\n      onComplete?.();\n    }\n  };\n  state.rafId = requestAnimationFrame(animate);\n  return cleanup;\n}\n\n// src/utils/scroll-to.ts\nfunction scrollTo(node, options = {}) {\n  if (!node) return;\n  const { top, left, behavior = \"smooth\", easing, duration } = options;\n  if (behavior === \"smooth\") {\n    smoothScroll(node, { top, left, easing, duration });\n  } else {\n    const scrollOptions = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.compact)({ behavior, top, left });\n    node.scrollTo(scrollOptions);\n  }\n}\nfunction scrollToEdge(node, edge, dir, behavior = \"smooth\", easing, duration) {\n  if (!node) return;\n  const maxLeft = node.scrollWidth - node.clientWidth;\n  const maxTop = node.scrollHeight - node.clientHeight;\n  const isRtl = dir === \"rtl\";\n  let targetScrollTop;\n  let targetScrollLeft;\n  switch (edge) {\n    case \"top\":\n      targetScrollTop = 0;\n      break;\n    case \"bottom\":\n      targetScrollTop = maxTop;\n      break;\n    case \"left\":\n      if (isRtl) {\n        const negative = node.scrollLeft <= 0;\n        targetScrollLeft = negative ? -maxLeft : 0;\n      } else {\n        targetScrollLeft = 0;\n      }\n      break;\n    case \"right\":\n      if (isRtl) {\n        const negative = node.scrollLeft <= 0;\n        targetScrollLeft = negative ? 0 : maxLeft;\n      } else {\n        targetScrollLeft = maxLeft;\n      }\n      break;\n  }\n  if (behavior === \"smooth\") {\n    smoothScroll(node, { top: targetScrollTop, left: targetScrollLeft, easing, duration });\n  } else {\n    const options = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.compact)({ left: targetScrollLeft, top: targetScrollTop, behavior });\n    node.scrollTo(options);\n  }\n}\n\n// src/scroll-area.connect.ts\nfunction connect(service, normalize) {\n  const { send, context, prop, scope } = service;\n  const cornerSize = context.get(\"cornerSize\");\n  const thumbSize = context.get(\"thumbSize\");\n  const hiddenState = context.get(\"hiddenState\");\n  const atSides = context.get(\"atSides\");\n  return {\n    isAtTop: atSides.top,\n    isAtBottom: atSides.bottom,\n    isAtLeft: atSides.left,\n    isAtRight: atSides.right,\n    hasOverflowX: !hiddenState.scrollbarXHidden,\n    hasOverflowY: !hiddenState.scrollbarYHidden,\n    getScrollProgress() {\n      return getScrollProgress(getViewportEl(scope), 0);\n    },\n    scrollToEdge(details) {\n      const { edge, behavior } = details;\n      return scrollToEdge(getViewportEl(scope), edge, prop(\"dir\"), behavior);\n    },\n    scrollTo(details) {\n      return scrollTo(getViewportEl(scope), details);\n    },\n    getScrollbarState(props2) {\n      const horizontal = props2.orientation === \"horizontal\";\n      return {\n        hovering: context.get(\"hovering\"),\n        scrolling: context.get(horizontal ? \"scrollingX\" : \"scrollingY\"),\n        hidden: horizontal ? hiddenState.scrollbarXHidden : hiddenState.scrollbarYHidden\n      };\n    },\n    getRootProps() {\n      return normalize.element({\n        ...parts.root.attrs,\n        id: getRootId(scope),\n        dir: prop(\"dir\"),\n        role: \"presentation\",\n        \"data-overflow-x\": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(!hiddenState.scrollbarXHidden),\n        \"data-overflow-y\": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(!hiddenState.scrollbarYHidden),\n        onPointerEnter(event) {\n          send({ type: \"root.pointerenter\", pointerType: event.pointerType });\n        },\n        onPointerMove(event) {\n          send({ type: \"root.pointerenter\", pointerType: event.pointerType });\n        },\n        onPointerDown({ pointerType }) {\n          send({ type: \"root.pointerdown\", pointerType });\n        },\n        onPointerLeave() {\n          send({ type: \"root.pointerleave\" });\n        },\n        style: {\n          position: \"relative\",\n          \"--corder-width\": (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.toPx)(cornerSize?.width),\n          \"--corder-height\": (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.toPx)(cornerSize?.height),\n          \"--thumb-width\": (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.toPx)(thumbSize?.width),\n          \"--thumb-height\": (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.toPx)(thumbSize?.height)\n        }\n      });\n    },\n    getViewportProps() {\n      const handleUserInteraction = () => {\n        send({ type: \"user.scroll\" });\n      };\n      return normalize.element({\n        ...parts.viewport.attrs,\n        role: \"presentation\",\n        \"data-ownedby\": getRootId(scope),\n        id: getViewportId(scope),\n        \"data-at-top\": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(atSides.top),\n        \"data-at-bottom\": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(atSides.bottom),\n        \"data-at-left\": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(atSides.left),\n        \"data-at-right\": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(atSides.right),\n        \"data-overflow-x\": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(!hiddenState.scrollbarXHidden),\n        \"data-overflow-y\": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(!hiddenState.scrollbarYHidden),\n        tabIndex: hiddenState.scrollbarXHidden || hiddenState.scrollbarYHidden ? void 0 : 0,\n        style: {\n          overflow: \"auto\"\n        },\n        onScroll(event) {\n          send({ type: \"viewport.scroll\", target: event.currentTarget });\n        },\n        onWheel: handleUserInteraction,\n        onTouchMove: handleUserInteraction,\n        onPointerMove: handleUserInteraction,\n        onPointerEnter: handleUserInteraction,\n        onKeyDown: handleUserInteraction\n      });\n    },\n    getContentProps() {\n      return normalize.element({\n        ...parts.content.attrs,\n        id: getContentId(scope),\n        role: \"presentation\",\n        \"data-overflow-x\": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(!hiddenState.scrollbarXHidden),\n        \"data-overflow-y\": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(!hiddenState.scrollbarYHidden),\n        style: {\n          minWidth: \"fit-content\"\n        }\n      });\n    },\n    getScrollbarProps(props2 = {}) {\n      const { orientation = \"vertical\" } = props2;\n      return normalize.element({\n        ...parts.scrollbar.attrs,\n        \"data-ownedby\": getRootId(scope),\n        \"data-orientation\": orientation,\n        \"data-scrolling\": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(context.get(orientation === \"horizontal\" ? \"scrollingX\" : \"scrollingY\")),\n        \"data-hover\": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(context.get(\"hovering\")),\n        \"data-overflow-x\": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(!hiddenState.scrollbarXHidden),\n        \"data-overflow-y\": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(!hiddenState.scrollbarYHidden),\n        onPointerUp() {\n          send({ type: \"scrollbar.pointerup\", orientation });\n        },\n        onPointerDown(event) {\n          if (event.button !== 0) {\n            return;\n          }\n          if (event.currentTarget !== event.target) {\n            return;\n          }\n          const point = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.getEventPoint)(event);\n          send({ type: \"scrollbar.pointerdown\", orientation, point });\n          event.stopPropagation();\n        },\n        style: {\n          position: \"absolute\",\n          touchAction: \"none\",\n          WebkitUserSelect: \"none\",\n          userSelect: \"none\",\n          ...orientation === \"vertical\" && {\n            top: 0,\n            bottom: `var(--corder-height)`,\n            insetInlineEnd: 0\n          },\n          ...orientation === \"horizontal\" && {\n            insetInlineStart: 0,\n            insetInlineEnd: `var(--corder-width)`,\n            bottom: 0\n          }\n        }\n      });\n    },\n    getThumbProps(props2 = {}) {\n      const { orientation = \"vertical\" } = props2;\n      return normalize.element({\n        ...parts.thumb.attrs,\n        \"data-ownedby\": getRootId(scope),\n        \"data-orientation\": orientation,\n        onPointerDown(event) {\n          if (event.button !== 0) return;\n          const point = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.getEventPoint)(event);\n          send({ type: \"thumb.pointerdown\", orientation, point });\n        },\n        style: {\n          ...orientation === \"vertical\" && {\n            height: \"var(--thumb-height)\"\n          },\n          ...orientation === \"horizontal\" && {\n            width: \"var(--thumb-width)\"\n          }\n        }\n      });\n    },\n    getCornerProps() {\n      return normalize.element({\n        ...parts.corner.attrs,\n        \"data-ownedby\": getRootId(scope),\n        \"data-hover\": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(context.get(\"hovering\")),\n        \"data-state\": hiddenState.cornerHidden ? \"hidden\" : \"visible\",\n        \"data-overflow-x\": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(!hiddenState.scrollbarXHidden),\n        \"data-overflow-y\": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(!hiddenState.scrollbarYHidden),\n        style: {\n          position: \"absolute\",\n          bottom: 0,\n          insetInlineEnd: 0,\n          width: \"var(--corder-width)\",\n          height: \"var(--corder-height)\"\n        }\n      });\n    }\n  };\n}\nfunction getScrollOffset(element, prop, axis) {\n  if (!element) return 0;\n  const styles = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(element);\n  const start = axis === \"x\" ? \"Left\" : \"Top\";\n  const end = axis === \"x\" ? \"Right\" : \"Bottom\";\n  return parseFloat(styles[`${prop}${start}`]) + parseFloat(styles[`${prop}${end}`]);\n}\n\n// src/utils/scroll-sides.ts\nfunction getScrollSides(node, dir) {\n  const scrollTop = node.scrollTop;\n  const scrollLeft = node.scrollLeft;\n  const isRtl = dir === \"rtl\";\n  const threshold = 1;\n  const hasVerticalScroll = node.scrollHeight - node.clientHeight > threshold;\n  const hasHorizontalScroll = node.scrollWidth - node.clientWidth > threshold;\n  const maxScrollLeft = node.scrollWidth - node.clientWidth;\n  const maxScrollTop = node.scrollHeight - node.clientHeight;\n  let atLeft = false;\n  let atRight = false;\n  let atTop = false;\n  let atBottom = false;\n  if (hasHorizontalScroll) {\n    if (isRtl) {\n      if (scrollLeft <= 0) {\n        atLeft = Math.abs(scrollLeft) >= maxScrollLeft - threshold;\n        atRight = Math.abs(scrollLeft) <= threshold;\n      } else {\n        atLeft = scrollLeft <= threshold;\n        atRight = scrollLeft >= maxScrollLeft - threshold;\n      }\n    } else {\n      atLeft = scrollLeft <= threshold;\n      atRight = scrollLeft >= maxScrollLeft - threshold;\n    }\n  }\n  if (hasVerticalScroll) {\n    atTop = scrollTop <= threshold;\n    atBottom = scrollTop >= maxScrollTop - threshold;\n  }\n  return {\n    top: atTop,\n    right: atRight,\n    bottom: atBottom,\n    left: atLeft\n  };\n}\n\n// src/utils/timeout.ts\nvar EMPTY = 0;\nvar Timeout = class {\n  constructor() {\n    __publicField(this, \"currentId\", EMPTY);\n    __publicField(this, \"clear\", () => {\n      if (this.currentId !== EMPTY) {\n        clearTimeout(this.currentId);\n        this.currentId = EMPTY;\n      }\n    });\n    __publicField(this, \"disposeEffect\", () => {\n      return this.clear;\n    });\n  }\n  start(delay, fn) {\n    this.clear();\n    this.currentId = setTimeout(() => {\n      this.currentId = EMPTY;\n      fn();\n    }, delay);\n  }\n  isStarted() {\n    return this.currentId !== EMPTY;\n  }\n};\n\n// src/scroll-area.machine.ts\nvar MIN_THUMB_SIZE = 20;\nvar SCROLL_TIMEOUT = 1e3;\nvar machine = (0,_zag_js_core__WEBPACK_IMPORTED_MODULE_3__.createMachine)({\n  props({ props: props2 }) {\n    return {\n      id: \"sv\",\n      ...props2\n    };\n  },\n  context({ bindable }) {\n    return {\n      scrollingX: bindable(() => ({ defaultValue: false })),\n      scrollingY: bindable(() => ({ defaultValue: false })),\n      hovering: bindable(() => ({ defaultValue: false })),\n      touchModality: bindable(() => ({ defaultValue: false })),\n      atSides: bindable(() => ({\n        defaultValue: { top: true, right: false, bottom: false, left: true }\n      })),\n      cornerSize: bindable(() => ({\n        defaultValue: { width: 0, height: 0 }\n      })),\n      thumbSize: bindable(() => ({\n        defaultValue: { width: 0, height: 0 }\n      })),\n      hiddenState: bindable(() => ({\n        defaultValue: {\n          scrollbarYHidden: false,\n          scrollbarXHidden: false,\n          cornerHidden: false\n        },\n        hash(a) {\n          return `Y:${a.scrollbarYHidden} X:${a.scrollbarXHidden} C:${a.cornerHidden}`;\n        }\n      }))\n    };\n  },\n  refs() {\n    return {\n      orientation: \"vertical\",\n      scrollPosition: { x: 0, y: 0 },\n      scrollYTimeout: new Timeout(),\n      scrollXTimeout: new Timeout(),\n      scrollEndTimeout: new Timeout(),\n      startX: 0,\n      startY: 0,\n      startScrollTop: 0,\n      startScrollLeft: 0,\n      programmaticScroll: true\n    };\n  },\n  initialState() {\n    return \"idle\";\n  },\n  watch({ track, prop, context, send }) {\n    track([() => prop(\"dir\"), () => context.hash(\"hiddenState\")], () => {\n      send({ type: \"thumb.measure\" });\n    });\n  },\n  effects: [\"trackContentResize\", \"trackViewportVisibility\", \"trackWheelEvent\"],\n  entry: [\"checkHovering\"],\n  exit: [\"clearTimeouts\"],\n  on: {\n    \"thumb.measure\": {\n      actions: [\"setThumbSize\"]\n    },\n    \"viewport.scroll\": {\n      actions: [\"setThumbSize\", \"setScrolling\", \"setProgrammaticScroll\"]\n    },\n    \"root.pointerenter\": {\n      actions: [\"setTouchModality\", \"setHovering\"]\n    },\n    \"root.pointerdown\": {\n      actions: [\"setTouchModality\"]\n    },\n    \"root.pointerleave\": {\n      actions: [\"clearHovering\"]\n    }\n  },\n  states: {\n    idle: {\n      on: {\n        \"scrollbar.pointerdown\": {\n          target: \"dragging\",\n          actions: [\"scrollToPointer\", \"startDragging\"]\n        },\n        \"thumb.pointerdown\": {\n          target: \"dragging\",\n          actions: [\"startDragging\"]\n        }\n      }\n    },\n    dragging: {\n      effects: [\"trackPointerMove\"],\n      on: {\n        \"thumb.pointermove\": {\n          actions: [\"setDraggingScroll\"]\n        },\n        \"scrollbar.pointerup\": {\n          target: \"idle\",\n          actions: [\"stopDragging\"]\n        },\n        \"thumb.pointerup\": {\n          target: \"idle\",\n          actions: [\"clearScrolling\", \"stopDragging\"]\n        }\n      }\n    }\n  },\n  implementations: {\n    actions: {\n      setTouchModality({ context, event }) {\n        context.set(\"touchModality\", event.pointerType === \"touch\");\n      },\n      setHovering({ context }) {\n        context.set(\"hovering\", true);\n      },\n      clearHovering({ context }) {\n        context.set(\"hovering\", false);\n      },\n      setProgrammaticScroll({ refs }) {\n        const scrollEndTimeout = refs.get(\"scrollEndTimeout\");\n        scrollEndTimeout.start(100, () => {\n          refs.set(\"programmaticScroll\", true);\n        });\n      },\n      clearScrolling({ context, event }) {\n        context.set(event.orientation === \"vertical\" ? \"scrollingY\" : \"scrollingX\", false);\n      },\n      setThumbSize({ context, scope, prop }) {\n        const viewportEl = getViewportEl(scope);\n        if (!viewportEl) return;\n        const scrollableContentHeight = viewportEl.scrollHeight;\n        const scrollableContentWidth = viewportEl.scrollWidth;\n        if (scrollableContentHeight === 0 || scrollableContentWidth === 0) return;\n        const scrollbarYEl = getScrollbarYEl(scope);\n        const scrollbarXEl = getScrollbarXEl(scope);\n        const thumbYEl = getThumbYEl(scope);\n        const thumbXEl = getThumbXEl(scope);\n        const viewportHeight = viewportEl.clientHeight;\n        const viewportWidth = viewportEl.clientWidth;\n        const scrollTop = viewportEl.scrollTop;\n        const scrollLeft = viewportEl.scrollLeft;\n        const scrollbarYHidden = viewportHeight >= scrollableContentHeight;\n        const scrollbarXHidden = viewportWidth >= scrollableContentWidth;\n        const ratioX = viewportWidth / scrollableContentWidth;\n        const ratioY = viewportHeight / scrollableContentHeight;\n        const nextWidth = scrollbarXHidden ? 0 : viewportWidth;\n        const nextHeight = scrollbarYHidden ? 0 : viewportHeight;\n        const scrollbarXOffset = getScrollOffset(scrollbarXEl, \"padding\", \"x\");\n        const scrollbarYOffset = getScrollOffset(scrollbarYEl, \"padding\", \"y\");\n        const thumbXOffset = getScrollOffset(thumbXEl, \"margin\", \"x\");\n        const thumbYOffset = getScrollOffset(thumbYEl, \"margin\", \"y\");\n        const idealNextWidth = nextWidth - scrollbarXOffset - thumbXOffset;\n        const idealNextHeight = nextHeight - scrollbarYOffset - thumbYOffset;\n        const maxNextWidth = scrollbarXEl ? Math.min(scrollbarXEl.offsetWidth, idealNextWidth) : idealNextWidth;\n        const maxNextHeight = scrollbarYEl ? Math.min(scrollbarYEl.offsetHeight, idealNextHeight) : idealNextHeight;\n        const clampedNextWidth = Math.max(MIN_THUMB_SIZE, maxNextWidth * ratioX);\n        const clampedNextHeight = Math.max(MIN_THUMB_SIZE, maxNextHeight * ratioY);\n        context.set(\"thumbSize\", (prevSize) => {\n          if (prevSize.height === clampedNextHeight && prevSize.width === clampedNextWidth) {\n            return prevSize;\n          }\n          return {\n            width: clampedNextWidth,\n            height: clampedNextHeight\n          };\n        });\n        if (scrollbarYEl && thumbYEl) {\n          const maxThumbOffsetY = scrollbarYEl.offsetHeight - clampedNextHeight - scrollbarYOffset - thumbYOffset;\n          const scrollRatioY = scrollTop / (scrollableContentHeight - viewportHeight);\n          const thumbOffsetY = Math.min(maxThumbOffsetY, Math.max(0, scrollRatioY * maxThumbOffsetY));\n          thumbYEl.style.transform = `translate3d(0,${thumbOffsetY}px,0)`;\n        }\n        if (scrollbarXEl && thumbXEl) {\n          const maxThumbOffsetX = scrollbarXEl.offsetWidth - clampedNextWidth - scrollbarXOffset - thumbXOffset;\n          const scrollRatioX = scrollLeft / (scrollableContentWidth - viewportWidth);\n          const thumbOffsetX = prop(\"dir\") === \"rtl\" ? (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.clampValue)(scrollRatioX * maxThumbOffsetX, -maxThumbOffsetX, 0) : (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.clampValue)(scrollRatioX * maxThumbOffsetX, 0, maxThumbOffsetX);\n          thumbXEl.style.transform = `translate3d(${thumbOffsetX}px,0,0)`;\n        }\n        const cornerEl = getCornerEl(scope);\n        if (cornerEl) {\n          if (scrollbarXHidden || scrollbarYHidden) {\n            context.set(\"cornerSize\", { width: 0, height: 0 });\n          } else if (!scrollbarXHidden && !scrollbarYHidden) {\n            const width = scrollbarYEl?.offsetWidth || 0;\n            const height = scrollbarXEl?.offsetHeight || 0;\n            context.set(\"cornerSize\", { width, height });\n          }\n        }\n        context.set(\"hiddenState\", (prevState) => {\n          const cornerHidden = scrollbarYHidden || scrollbarXHidden;\n          if (prevState.scrollbarYHidden === scrollbarYHidden && prevState.scrollbarXHidden === scrollbarXHidden && prevState.cornerHidden === cornerHidden) {\n            return prevState;\n          }\n          return {\n            scrollbarYHidden,\n            scrollbarXHidden,\n            cornerHidden\n          };\n        });\n        context.set(\"atSides\", (prev) => {\n          const next = getScrollSides(viewportEl, prop(\"dir\"));\n          if ((0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.isEqual)(prev, next)) return prev;\n          return next;\n        });\n      },\n      checkHovering({ scope, context }) {\n        const viewportEl = getViewportEl(scope);\n        if (viewportEl?.matches(\":hover\")) {\n          context.set(\"hovering\", true);\n        }\n      },\n      setScrolling({ event, refs, context, prop }) {\n        const scrollPosition = {\n          x: event.target.scrollLeft,\n          y: event.target.scrollTop\n        };\n        const scrollPositionRef = refs.get(\"scrollPosition\");\n        const offsetX = scrollPosition.x - scrollPositionRef.x;\n        const offsetY = scrollPosition.y - scrollPositionRef.y;\n        refs.set(\"scrollPosition\", scrollPosition);\n        context.set(\"atSides\", (prev) => {\n          const next = getScrollSides(event.target, prop(\"dir\"));\n          if ((0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.isEqual)(prev, next)) return prev;\n          return next;\n        });\n        if (offsetY !== 0) {\n          context.set(\"scrollingY\", true);\n          refs.get(\"scrollYTimeout\").start(SCROLL_TIMEOUT, () => {\n            context.set(\"scrollingY\", false);\n          });\n        }\n        if (offsetX !== 0) {\n          context.set(\"scrollingX\", true);\n          refs.get(\"scrollXTimeout\").start(SCROLL_TIMEOUT, () => {\n            context.set(\"scrollingX\", false);\n          });\n        }\n      },\n      scrollToPointer({ event, scope, prop }) {\n        const viewportEl = getViewportEl(scope);\n        if (!viewportEl) return;\n        const thumbYRef = getThumbYEl(scope);\n        const scrollbarYRef = getScrollbarYEl(scope);\n        const thumbXRef = getThumbXEl(scope);\n        const scrollbarXRef = getScrollbarXEl(scope);\n        const client = event.point;\n        if (thumbYRef && scrollbarYRef && event.orientation === \"vertical\") {\n          const thumbYOffset = getScrollOffset(thumbYRef, \"margin\", \"y\");\n          const scrollbarYOffset = getScrollOffset(scrollbarYRef, \"padding\", \"y\");\n          const thumbHeight = thumbYRef.offsetHeight;\n          const trackRectY = scrollbarYRef.getBoundingClientRect();\n          const clickY = client.y - trackRectY.top - thumbHeight / 2 - scrollbarYOffset + thumbYOffset / 2;\n          const scrollableContentHeight = viewportEl.scrollHeight;\n          const viewportHeight = viewportEl.clientHeight;\n          const maxThumbOffsetY = scrollbarYRef.offsetHeight - thumbHeight - scrollbarYOffset - thumbYOffset;\n          const scrollRatioY = clickY / maxThumbOffsetY;\n          const newScrollTop = scrollRatioY * (scrollableContentHeight - viewportHeight);\n          viewportEl.scrollTop = newScrollTop;\n        }\n        if (thumbXRef && scrollbarXRef && event.orientation === \"horizontal\") {\n          const thumbXOffset = getScrollOffset(thumbXRef, \"margin\", \"x\");\n          const scrollbarXOffset = getScrollOffset(scrollbarXRef, \"padding\", \"x\");\n          const thumbWidth = thumbXRef.offsetWidth;\n          const trackRectX = scrollbarXRef.getBoundingClientRect();\n          const clickX = client.x - trackRectX.left - thumbWidth / 2 - scrollbarXOffset + thumbXOffset / 2;\n          const scrollableContentWidth = viewportEl.scrollWidth;\n          const viewportWidth = viewportEl.clientWidth;\n          const maxThumbOffsetX = scrollbarXRef.offsetWidth - thumbWidth - scrollbarXOffset - thumbXOffset;\n          const scrollRatioX = clickX / maxThumbOffsetX;\n          let newScrollLeft;\n          if (prop(\"dir\") === \"rtl\") {\n            newScrollLeft = (1 - scrollRatioX) * (scrollableContentWidth - viewportWidth);\n            if (viewportEl.scrollLeft <= 0) {\n              newScrollLeft = -newScrollLeft;\n            }\n          } else {\n            newScrollLeft = scrollRatioX * (scrollableContentWidth - viewportWidth);\n          }\n          viewportEl.scrollLeft = newScrollLeft;\n        }\n      },\n      startDragging({ event, refs, scope }) {\n        refs.set(\"startX\", event.point.x);\n        refs.set(\"startY\", event.point.y);\n        refs.set(\"orientation\", event.orientation);\n        const viewportEl = getViewportEl(scope);\n        if (!viewportEl) return;\n        refs.set(\"startScrollTop\", viewportEl.scrollTop);\n        refs.set(\"startScrollLeft\", viewportEl.scrollLeft);\n      },\n      setDraggingScroll({ event, refs, scope, context }) {\n        const startY = refs.get(\"startY\");\n        const startX = refs.get(\"startX\");\n        const startScrollTop = refs.get(\"startScrollTop\");\n        const startScrollLeft = refs.get(\"startScrollLeft\");\n        const client = event.point;\n        const deltaY = client.y - startY;\n        const deltaX = client.x - startX;\n        const viewportEl = getViewportEl(scope);\n        if (!viewportEl) return;\n        const scrollableContentHeight = viewportEl.scrollHeight;\n        const viewportHeight = viewportEl.clientHeight;\n        const scrollableContentWidth = viewportEl.scrollWidth;\n        const viewportWidth = viewportEl.clientWidth;\n        const orientation = refs.get(\"orientation\");\n        const thumbYEl = getThumbYEl(scope);\n        const scrollbarYEl = getScrollbarYEl(scope);\n        if (thumbYEl && scrollbarYEl && orientation === \"vertical\") {\n          const scrollbarYOffset = getScrollOffset(scrollbarYEl, \"padding\", \"y\");\n          const thumbYOffset = getScrollOffset(thumbYEl, \"margin\", \"y\");\n          const thumbHeight = thumbYEl.offsetHeight;\n          const maxThumbOffsetY = scrollbarYEl.offsetHeight - thumbHeight - scrollbarYOffset - thumbYOffset;\n          const scrollRatioY = deltaY / maxThumbOffsetY;\n          viewportEl.scrollTop = startScrollTop + scrollRatioY * (scrollableContentHeight - viewportHeight);\n          context.set(\"scrollingY\", true);\n          refs.get(\"scrollYTimeout\").start(SCROLL_TIMEOUT, () => {\n            context.set(\"scrollingY\", false);\n          });\n        }\n        const thumbXEl = getThumbXEl(scope);\n        const scrollbarXEl = getScrollbarXEl(scope);\n        if (thumbXEl && scrollbarXEl && orientation === \"horizontal\") {\n          const scrollbarXOffset = getScrollOffset(scrollbarXEl, \"padding\", \"x\");\n          const thumbXOffset = getScrollOffset(thumbXEl, \"margin\", \"x\");\n          const thumbWidth = thumbXEl.offsetWidth;\n          const maxThumbOffsetX = scrollbarXEl.offsetWidth - thumbWidth - scrollbarXOffset - thumbXOffset;\n          const scrollRatioX = deltaX / maxThumbOffsetX;\n          viewportEl.scrollLeft = startScrollLeft + scrollRatioX * (scrollableContentWidth - viewportWidth);\n          context.set(\"scrollingX\", true);\n          refs.get(\"scrollXTimeout\").start(SCROLL_TIMEOUT, () => {\n            context.set(\"scrollingX\", false);\n          });\n        }\n      },\n      stopDragging({ refs }) {\n        refs.set(\"orientation\", null);\n      },\n      clearTimeouts({ refs }) {\n        refs.get(\"scrollYTimeout\").clear();\n        refs.get(\"scrollXTimeout\").clear();\n        refs.get(\"scrollEndTimeout\").clear();\n      }\n    },\n    effects: {\n      trackContentResize({ scope, send }) {\n        const contentEl = getContentEl(scope);\n        if (!contentEl) return;\n        const win = scope.getWin();\n        const obs = new win.ResizeObserver(() => {\n          setTimeout(() => {\n            send({ type: \"thumb.measure\" });\n          }, 1);\n        });\n        obs.observe(contentEl);\n        return () => {\n          obs.disconnect();\n        };\n      },\n      trackViewportVisibility({ scope, send }) {\n        const win = scope.getWin();\n        const viewportEl = getViewportEl(scope);\n        if (!viewportEl) return;\n        const observer = new win.IntersectionObserver((entries) => {\n          entries.forEach((entry) => {\n            if (entry.intersectionRatio > 0) {\n              send({ type: \"thumb.measure\" });\n              observer.disconnect();\n            }\n          });\n        });\n        observer.observe(viewportEl);\n        return () => {\n          observer.disconnect();\n        };\n      },\n      trackWheelEvent({ scope }) {\n        const scrollbarYEl = getScrollbarYEl(scope);\n        const scrollbarXEl = getScrollbarXEl(scope);\n        if (!scrollbarYEl && !scrollbarXEl) return;\n        const onWheel = (event) => {\n          const viewportEl = getViewportEl(scope);\n          if (!viewportEl || event.ctrlKey) return;\n          const orientation = event.currentTarget.dataset.orientation;\n          if (orientation === \"vertical\") {\n            const canScrollY = viewportEl.scrollHeight > viewportEl.clientHeight;\n            const atTop = viewportEl.scrollTop === 0 && event.deltaY < 0;\n            const atBottom = viewportEl.scrollTop === viewportEl.scrollHeight - viewportEl.clientHeight && event.deltaY > 0;\n            const shouldScroll = canScrollY && event.deltaY !== 0 && !(atTop || atBottom);\n            if (!shouldScroll) return;\n            event.preventDefault();\n            viewportEl.scrollTop += event.deltaY;\n          } else if (orientation === \"horizontal\") {\n            const canScrollX = viewportEl.scrollWidth > viewportEl.clientWidth;\n            const atLeft = viewportEl.scrollLeft === 0 && event.deltaX < 0;\n            const atRight = viewportEl.scrollLeft === viewportEl.scrollWidth - viewportEl.clientWidth && event.deltaX > 0;\n            const shouldScroll = canScrollX && event.deltaX !== 0 && !(atLeft || atRight);\n            if (!shouldScroll) return;\n            event.preventDefault();\n            viewportEl.scrollLeft += event.deltaX;\n          }\n        };\n        return (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.callAll)(\n          scrollbarYEl && (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.addDomEvent)(scrollbarYEl, \"wheel\", onWheel, { passive: false }),\n          scrollbarXEl && (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.addDomEvent)(scrollbarXEl, \"wheel\", onWheel, { passive: false })\n        );\n      },\n      trackPointerMove({ scope, send, refs }) {\n        const doc = scope.getDoc();\n        const orientation = refs.get(\"orientation\");\n        return (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.trackPointerMove)(doc, {\n          onPointerMove({ point }) {\n            send({ type: \"thumb.pointermove\", orientation, point });\n          },\n          onPointerUp() {\n            send({ type: \"thumb.pointerup\", orientation });\n          }\n        });\n      }\n    }\n  }\n});\nvar props = (0,_zag_js_types__WEBPACK_IMPORTED_MODULE_4__.createProps)()([\"dir\", \"getRootNode\", \"ids\", \"id\"]);\nvar splitProps = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.createSplitProps)(props);\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0B6YWctanMrc2Nyb2xsLWFyZWFAMS4yMS43L25vZGVfbW9kdWxlcy9AemFnLWpzL3Njcm9sbC1hcmVhL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBZ0Q7QUFDb0U7QUFDdEI7QUFDakQ7QUFDRDs7QUFFNUM7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0EsY0FBYyw4REFBYTtBQUMzQjtBQUNBLHlEQUF5RCxPQUFPO0FBQ2hFLGlFQUFpRSxPQUFPO0FBQ3hFLCtEQUErRCxPQUFPO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix3REFBSyxxRkFBcUYsZUFBZTtBQUN4SSwrQkFBK0Isd0RBQUssbUZBQW1GLGVBQWU7QUFDdEksMkJBQTJCLHdEQUFLLHVGQUF1RixlQUFlO0FBQ3RJLDJCQUEyQix3REFBSyxxRkFBcUYsZUFBZTtBQUNwSSwyQkFBMkIsd0RBQUsscURBQXFELGVBQWU7O0FBRXBHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMsVUFBVSxxRUFBcUU7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBLFVBQVUsbURBQW1EO0FBQzdEO0FBQ0EseUJBQXlCLDZCQUE2QjtBQUN0RCxJQUFJO0FBQ0osMEJBQTBCLHNEQUFPLEdBQUcscUJBQXFCO0FB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Q3ZCLGlCQUFpQiwrREFBZ0I7O0FBRXVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHV0dXJpL3V0dXJpLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AemFnLWpzK3Njcm9sbC1hcmVhQDEuMjEuNy9ub2RlX21vZHVsZXMvQHphZy1qcy9zY3JvbGwtYXJlYS9kaXN0L2luZGV4Lm1qcz8wN2ViIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZUFuYXRvbXkgfSBmcm9tICdAemFnLWpzL2FuYXRvbXknO1xuaW1wb3J0IHsgdHJhY2tQb2ludGVyTW92ZSwgcXVlcnksIGFkZERvbUV2ZW50LCBnZXRDb21wdXRlZFN0eWxlLCBkYXRhQXR0ciwgZ2V0RXZlbnRQb2ludCB9IGZyb20gJ0B6YWctanMvZG9tLXF1ZXJ5JztcbmltcG9ydCB7IGNhbGxBbGwsIGlzRXF1YWwsIGNsYW1wVmFsdWUsIGNyZWF0ZVNwbGl0UHJvcHMsIHRvUHgsIGNvbXBhY3QgfSBmcm9tICdAemFnLWpzL3V0aWxzJztcbmltcG9ydCB7IGNyZWF0ZU1hY2hpbmUgfSBmcm9tICdAemFnLWpzL2NvcmUnO1xuaW1wb3J0IHsgY3JlYXRlUHJvcHMgfSBmcm9tICdAemFnLWpzL3R5cGVzJztcblxudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3B1YmxpY0ZpZWxkID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4gX19kZWZOb3JtYWxQcm9wKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbnZhciBhbmF0b215ID0gY3JlYXRlQW5hdG9teShcInNjcm9sbC1hcmVhXCIpLnBhcnRzKFwicm9vdFwiLCBcInZpZXdwb3J0XCIsIFwiY29udGVudFwiLCBcInNjcm9sbGJhclwiLCBcInRodW1iXCIsIFwiY29ybmVyXCIpO1xudmFyIHBhcnRzID0gYW5hdG9teS5idWlsZCgpO1xudmFyIGdldFJvb3RJZCA9IChjdHgpID0+IGN0eC5pZHM/LnJvb3QgPz8gYHNjcm9sbC1hcmVhLSR7Y3R4LmlkfWA7XG52YXIgZ2V0Vmlld3BvcnRJZCA9IChjdHgpID0+IGN0eC5pZHM/LnZpZXdwb3J0ID8/IGBzY3JvbGwtYXJlYS0ke2N0eC5pZH06dmlld3BvcnRgO1xudmFyIGdldENvbnRlbnRJZCA9IChjdHgpID0+IGN0eC5pZHM/LmNvbnRlbnQgPz8gYHNjcm9sbC1hcmVhLSR7Y3R4LmlkfTpjb250ZW50YDtcbnZhciBnZXRSb290RWwgPSAoY3R4KSA9PiBjdHguZ2V0QnlJZChnZXRSb290SWQoY3R4KSk7XG52YXIgZ2V0Vmlld3BvcnRFbCA9IChjdHgpID0+IGN0eC5nZXRCeUlkKGdldFZpZXdwb3J0SWQoY3R4KSk7XG52YXIgZ2V0Q29udGVudEVsID0gKGN0eCkgPT4gY3R4LmdldEJ5SWQoZ2V0Q29udGVudElkKGN0eCkpO1xudmFyIGdldFNjcm9sbGJhclhFbCA9IChjdHgpID0+IHF1ZXJ5KGdldFJvb3RFbChjdHgpLCBgW2RhdGEtcGFydD1zY3JvbGxiYXJdW2RhdGEtb3JpZW50YXRpb249aG9yaXpvbnRhbF1bZGF0YS1vd25lZGJ5PVwiJHtnZXRSb290SWQoY3R4KX1cIl1gKTtcbnZhciBnZXRTY3JvbGxiYXJZRWwgPSAoY3R4KSA9PiBxdWVyeShnZXRSb290RWwoY3R4KSwgYFtkYXRhLXBhcnQ9c2Nyb2xsYmFyXVtkYXRhLW9yaWVudGF0aW9uPXZlcnRpY2FsXVtkYXRhLW93bmVkYnk9XCIke2dldFJvb3RJZChjdHgpfVwiXWApO1xudmFyIGdldFRodW1iWEVsID0gKGN0eCkgPT4gcXVlcnkoZ2V0U2Nyb2xsYmFyWEVsKGN0eCksIGBbZGF0YS1wYXJ0PXRodW1iXVtkYXRhLW9yaWVudGF0aW9uPWhvcml6b250YWxdW2RhdGEtb3duZWRieT1cIiR7Z2V0Um9vdElkKGN0eCl9XCJdYCk7XG52YXIgZ2V0VGh1bWJZRWwgPSAoY3R4KSA9PiBxdWVyeShnZXRTY3JvbGxiYXJZRWwoY3R4KSwgYFtkYXRhLXBhcnQ9dGh1bWJdW2RhdGEtb3JpZW50YXRpb249dmVydGljYWxdW2RhdGEtb3duZWRieT1cIiR7Z2V0Um9vdElkKGN0eCl9XCJdYCk7XG52YXIgZ2V0Q29ybmVyRWwgPSAoY3R4KSA9PiBxdWVyeShnZXRSb290RWwoY3R4KSwgYFtkYXRhLXBhcnQ9Y29ybmVyXVtkYXRhLW93bmVkYnk9XCIke2dldFJvb3RJZChjdHgpfVwiXWApO1xuXG4vLyBzcmMvdXRpbHMvc2Nyb2xsLXByb2dyZXNzLnRzXG5mdW5jdGlvbiBnZXRTY3JvbGxQcm9ncmVzcyhlbGVtZW50LCBzY3JvbGxUaHJlc2hvbGQpIHtcbiAgaWYgKCFlbGVtZW50KSByZXR1cm4gRU1QVFlfU0NST0xMX1BST0dSRVNTO1xuICBsZXQgcHJvZ3Jlc3NYID0gMDtcbiAgbGV0IHByb2dyZXNzWSA9IDA7XG4gIGNvbnN0IG1heFNjcm9sbFggPSBlbGVtZW50LnNjcm9sbFdpZHRoIC0gZWxlbWVudC5jbGllbnRXaWR0aDtcbiAgaWYgKG1heFNjcm9sbFggPiBzY3JvbGxUaHJlc2hvbGQpIHtcbiAgICBwcm9ncmVzc1ggPSBNYXRoLm1pbigxLCBNYXRoLm1heCgwLCBlbGVtZW50LnNjcm9sbExlZnQgLyBtYXhTY3JvbGxYKSk7XG4gIH1cbiAgY29uc3QgbWF4U2Nyb2xsWSA9IGVsZW1lbnQuc2Nyb2xsSGVpZ2h0IC0gZWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gIGlmIChtYXhTY3JvbGxZID4gc2Nyb2xsVGhyZXNob2xkKSB7XG4gICAgcHJvZ3Jlc3NZID0gTWF0aC5taW4oMSwgTWF0aC5tYXgoMCwgZWxlbWVudC5zY3JvbGxUb3AgLyBtYXhTY3JvbGxZKSk7XG4gIH1cbiAgcmV0dXJuIHsgeDogcHJvZ3Jlc3NYLCB5OiBwcm9ncmVzc1kgfTtcbn1cbnZhciBFTVBUWV9TQ1JPTExfUFJPR1JFU1MgPSB7IHg6IDAsIHk6IDAgfTtcblxuLy8gc3JjL3V0aWxzL3Ntb290aC1zY3JvbGwudHNcbnZhciBEVVJBVElPTiA9IDMwMDtcbnZhciBFQVNFX09VVF9RVUFEID0gKHQpID0+IHQgKiAoMiAtIHQpO1xuZnVuY3Rpb24gc21vb3RoU2Nyb2xsKG5vZGUsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7IHRvcCwgbGVmdCwgZHVyYXRpb24gPSBEVVJBVElPTiwgZWFzaW5nID0gRUFTRV9PVVRfUVVBRCwgb25Db21wbGV0ZSB9ID0gb3B0aW9ucztcbiAgaWYgKCFub2RlKSByZXR1cm47XG4gIGNvbnN0IHN0YXRlID0ge1xuICAgIHN0YXJ0VGltZTogMCxcbiAgICBzdGFydFNjcm9sbFRvcDogbm9kZS5zY3JvbGxUb3AsXG4gICAgc3RhcnRTY3JvbGxMZWZ0OiBub2RlLnNjcm9sbExlZnQsXG4gICAgdGFyZ2V0U2Nyb2xsVG9wOiB0b3AgPz8gbm9kZS5zY3JvbGxUb3AsXG4gICAgdGFyZ2V0U2Nyb2xsTGVmdDogbGVmdCA/PyBub2RlLnNjcm9sbExlZnRcbiAgfTtcbiAgbGV0IGNhbmNlbGxlZCA9IGZhbHNlO1xuICBjb25zdCBjbGVhbnVwID0gKCkgPT4ge1xuICAgIGlmIChzdGF0ZS5yYWZJZCkge1xuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoc3RhdGUucmFmSWQpO1xuICAgICAgc3RhdGUucmFmSWQgPSB2b2lkIDA7XG4gICAgfVxuICAgIGNhbmNlbGxlZCA9IHRydWU7XG4gIH07XG4gIGNvbnN0IGFuaW1hdGUgPSAoY3VycmVudFRpbWUpID0+IHtcbiAgICBpZiAoY2FuY2VsbGVkKSByZXR1cm47XG4gICAgaWYgKHN0YXRlLnN0YXJ0VGltZSA9PT0gMCkge1xuICAgICAgc3RhdGUuc3RhcnRUaW1lID0gY3VycmVudFRpbWU7XG4gICAgfVxuICAgIGNvbnN0IGVsYXBzZWQgPSBjdXJyZW50VGltZSAtIHN0YXRlLnN0YXJ0VGltZTtcbiAgICBjb25zdCBwcm9ncmVzcyA9IE1hdGgubWluKGVsYXBzZWQgLyBkdXJhdGlvbiwgMSk7XG4gICAgY29uc3QgZWFzZWRQcm9ncmVzcyA9IGVhc2luZyhwcm9ncmVzcyk7XG4gICAgY29uc3QgZGVsdGFUb3AgPSBzdGF0ZS50YXJnZXRTY3JvbGxUb3AgLSBzdGF0ZS5zdGFydFNjcm9sbFRvcDtcbiAgICBjb25zdCBkZWx0YUxlZnQgPSBzdGF0ZS50YXJnZXRTY3JvbGxMZWZ0IC0gc3RhdGUuc3RhcnRTY3JvbGxMZWZ0O1xuICAgIG5vZGUuc2Nyb2xsVG9wID0gc3RhdGUuc3RhcnRTY3JvbGxUb3AgKyBkZWx0YVRvcCAqIGVhc2VkUHJvZ3Jlc3M7XG4gICAgbm9kZS5zY3JvbGxMZWZ0ID0gc3RhdGUuc3RhcnRTY3JvbGxMZWZ0ICsgZGVsdGFMZWZ0ICogZWFzZWRQcm9ncmVzcztcbiAgICBpZiAocHJvZ3Jlc3MgPCAxKSB7XG4gICAgICBzdGF0ZS5yYWZJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb25Db21wbGV0ZT8uKCk7XG4gICAgfVxuICB9O1xuICBzdGF0ZS5yYWZJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKTtcbiAgcmV0dXJuIGNsZWFudXA7XG59XG5cbi8vIHNyYy91dGlscy9zY3JvbGwtdG8udHNcbmZ1bmN0aW9uIHNjcm9sbFRvKG5vZGUsIG9wdGlvbnMgPSB7fSkge1xuICBpZiAoIW5vZGUpIHJldHVybjtcbiAgY29uc3QgeyB0b3AsIGxlZnQsIGJlaGF2aW9yID0gXCJzbW9vdGhcIiwgZWFzaW5nLCBkdXJhdGlvbiB9ID0gb3B0aW9ucztcbiAgaWYgKGJlaGF2aW9yID09PSBcInNtb290aFwiKSB7XG4gICAgc21vb3RoU2Nyb2xsKG5vZGUsIHsgdG9wLCBsZWZ0LCBlYXNpbmcsIGR1cmF0aW9uIH0pO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHNjcm9sbE9wdGlvbnMgPSBjb21wYWN0KHsgYmVoYXZpb3IsIHRvcCwgbGVmdCB9KTtcbiAgICBub2RlLnNjcm9sbFRvKHNjcm9sbE9wdGlvbnMpO1xuICB9XG59XG5mdW5jdGlvbiBzY3JvbGxUb0VkZ2Uobm9kZSwgZWRnZSwgZGlyLCBiZWhhdmlvciA9IFwic21vb3RoXCIsIGVhc2luZywgZHVyYXRpb24pIHtcbiAgaWYgKCFub2RlKSByZXR1cm47XG4gIGNvbnN0IG1heExlZnQgPSBub2RlLnNjcm9sbFdpZHRoIC0gbm9kZS5jbGllbnRXaWR0aDtcbiAgY29uc3QgbWF4VG9wID0gbm9kZS5zY3JvbGxIZWlnaHQgLSBub2RlLmNsaWVudEhlaWdodDtcbiAgY29uc3QgaXNSdGwgPSBkaXIgPT09IFwicnRsXCI7XG4gIGxldCB0YXJnZXRTY3JvbGxUb3A7XG4gIGxldCB0YXJnZXRTY3JvbGxMZWZ0O1xuICBzd2l0Y2ggKGVkZ2UpIHtcbiAgICBjYXNlIFwidG9wXCI6XG4gICAgICB0YXJnZXRTY3JvbGxUb3AgPSAwO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImJvdHRvbVwiOlxuICAgICAgdGFyZ2V0U2Nyb2xsVG9wID0gbWF4VG9wO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImxlZnRcIjpcbiAgICAgIGlmIChpc1J0bCkge1xuICAgICAgICBjb25zdCBuZWdhdGl2ZSA9IG5vZGUuc2Nyb2xsTGVmdCA8PSAwO1xuICAgICAgICB0YXJnZXRTY3JvbGxMZWZ0ID0gbmVnYXRpdmUgPyAtbWF4TGVmdCA6IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YXJnZXRTY3JvbGxMZWZ0ID0gMDtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJyaWdodFwiOlxuICAgICAgaWYgKGlzUnRsKSB7XG4gICAgICAgIGNvbnN0IG5lZ2F0aXZlID0gbm9kZS5zY3JvbGxMZWZ0IDw9IDA7XG4gICAgICAgIHRhcmdldFNjcm9sbExlZnQgPSBuZWdhdGl2ZSA/IDAgOiBtYXhMZWZ0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFyZ2V0U2Nyb2xsTGVmdCA9IG1heExlZnQ7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgfVxuICBpZiAoYmVoYXZpb3IgPT09IFwic21vb3RoXCIpIHtcbiAgICBzbW9vdGhTY3JvbGwobm9kZSwgeyB0b3A6IHRhcmdldFNjcm9sbFRvcCwgbGVmdDogdGFyZ2V0U2Nyb2xsTGVmdCwgZWFzaW5nLCBkdXJhdGlvbiB9KTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBvcHRpb25zID0gY29tcGFjdCh7IGxlZnQ6IHRhcmdldFNjcm9sbExlZnQsIHRvcDogdGFyZ2V0U2Nyb2xsVG9wLCBiZWhhdmlvciB9KTtcbiAgICBub2RlLnNjcm9sbFRvKG9wdGlvbnMpO1xuICB9XG59XG5cbi8vIHNyYy9zY3JvbGwtYXJlYS5jb25uZWN0LnRzXG5mdW5jdGlvbiBjb25uZWN0KHNlcnZpY2UsIG5vcm1hbGl6ZSkge1xuICBjb25zdCB7IHNlbmQsIGNvbnRleHQsIHByb3AsIHNjb3BlIH0gPSBzZXJ2aWNlO1xuICBjb25zdCBjb3JuZXJTaXplID0gY29udGV4dC5nZXQoXCJjb3JuZXJTaXplXCIpO1xuICBjb25zdCB0aHVtYlNpemUgPSBjb250ZXh0LmdldChcInRodW1iU2l6ZVwiKTtcbiAgY29uc3QgaGlkZGVuU3RhdGUgPSBjb250ZXh0LmdldChcImhpZGRlblN0YXRlXCIpO1xuICBjb25zdCBhdFNpZGVzID0gY29udGV4dC5nZXQoXCJhdFNpZGVzXCIpO1xuICByZXR1cm4ge1xuICAgIGlzQXRUb3A6IGF0U2lkZXMudG9wLFxuICAgIGlzQXRCb3R0b206IGF0U2lkZXMuYm90dG9tLFxuICAgIGlzQXRMZWZ0OiBhdFNpZGVzLmxlZnQsXG4gICAgaXNBdFJpZ2h0OiBhdFNpZGVzLnJpZ2h0LFxuICAgIGhhc092ZXJmbG93WDogIWhpZGRlblN0YXRlLnNjcm9sbGJhclhIaWRkZW4sXG4gICAgaGFzT3ZlcmZsb3dZOiAhaGlkZGVuU3RhdGUuc2Nyb2xsYmFyWUhpZGRlbixcbiAgICBnZXRTY3JvbGxQcm9ncmVzcygpIHtcbiAgICAgIHJldHVybiBnZXRTY3JvbGxQcm9ncmVzcyhnZXRWaWV3cG9ydEVsKHNjb3BlKSwgMCk7XG4gICAgfSxcbiAgICBzY3JvbGxUb0VkZ2UoZGV0YWlscykge1xuICAgICAgY29uc3QgeyBlZGdlLCBiZWhhdmlvciB9ID0gZGV0YWlscztcbiAgICAgIHJldHVybiBzY3JvbGxUb0VkZ2UoZ2V0Vmlld3BvcnRFbChzY29wZSksIGVkZ2UsIHByb3AoXCJkaXJcIiksIGJlaGF2aW9yKTtcbiAgICB9LFxuICAgIHNjcm9sbFRvKGRldGFpbHMpIHtcbiAgICAgIHJldHVybiBzY3JvbGxUbyhnZXRWaWV3cG9ydEVsKHNjb3BlKSwgZGV0YWlscyk7XG4gICAgfSxcbiAgICBnZXRTY3JvbGxiYXJTdGF0ZShwcm9wczIpIHtcbiAgICAgIGNvbnN0IGhvcml6b250YWwgPSBwcm9wczIub3JpZW50YXRpb24gPT09IFwiaG9yaXpvbnRhbFwiO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaG92ZXJpbmc6IGNvbnRleHQuZ2V0KFwiaG92ZXJpbmdcIiksXG4gICAgICAgIHNjcm9sbGluZzogY29udGV4dC5nZXQoaG9yaXpvbnRhbCA/IFwic2Nyb2xsaW5nWFwiIDogXCJzY3JvbGxpbmdZXCIpLFxuICAgICAgICBoaWRkZW46IGhvcml6b250YWwgPyBoaWRkZW5TdGF0ZS5zY3JvbGxiYXJYSGlkZGVuIDogaGlkZGVuU3RhdGUuc2Nyb2xsYmFyWUhpZGRlblxuICAgICAgfTtcbiAgICB9LFxuICAgIGdldFJvb3RQcm9wcygpIHtcbiAgICAgIHJldHVybiBub3JtYWxpemUuZWxlbWVudCh7XG4gICAgICAgIC4uLnBhcnRzLnJvb3QuYXR0cnMsXG4gICAgICAgIGlkOiBnZXRSb290SWQoc2NvcGUpLFxuICAgICAgICBkaXI6IHByb3AoXCJkaXJcIiksXG4gICAgICAgIHJvbGU6IFwicHJlc2VudGF0aW9uXCIsXG4gICAgICAgIFwiZGF0YS1vdmVyZmxvdy14XCI6IGRhdGFBdHRyKCFoaWRkZW5TdGF0ZS5zY3JvbGxiYXJYSGlkZGVuKSxcbiAgICAgICAgXCJkYXRhLW92ZXJmbG93LXlcIjogZGF0YUF0dHIoIWhpZGRlblN0YXRlLnNjcm9sbGJhcllIaWRkZW4pLFxuICAgICAgICBvblBvaW50ZXJFbnRlcihldmVudCkge1xuICAgICAgICAgIHNlbmQoeyB0eXBlOiBcInJvb3QucG9pbnRlcmVudGVyXCIsIHBvaW50ZXJUeXBlOiBldmVudC5wb2ludGVyVHlwZSB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25Qb2ludGVyTW92ZShldmVudCkge1xuICAgICAgICAgIHNlbmQoeyB0eXBlOiBcInJvb3QucG9pbnRlcmVudGVyXCIsIHBvaW50ZXJUeXBlOiBldmVudC5wb2ludGVyVHlwZSB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25Qb2ludGVyRG93bih7IHBvaW50ZXJUeXBlIH0pIHtcbiAgICAgICAgICBzZW5kKHsgdHlwZTogXCJyb290LnBvaW50ZXJkb3duXCIsIHBvaW50ZXJUeXBlIH0pO1xuICAgICAgICB9LFxuICAgICAgICBvblBvaW50ZXJMZWF2ZSgpIHtcbiAgICAgICAgICBzZW5kKHsgdHlwZTogXCJyb290LnBvaW50ZXJsZWF2ZVwiIH0pO1xuICAgICAgICB9LFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsXG4gICAgICAgICAgXCItLWNvcmRlci13aWR0aFwiOiB0b1B4KGNvcm5lclNpemU/LndpZHRoKSxcbiAgICAgICAgICBcIi0tY29yZGVyLWhlaWdodFwiOiB0b1B4KGNvcm5lclNpemU/LmhlaWdodCksXG4gICAgICAgICAgXCItLXRodW1iLXdpZHRoXCI6IHRvUHgodGh1bWJTaXplPy53aWR0aCksXG4gICAgICAgICAgXCItLXRodW1iLWhlaWdodFwiOiB0b1B4KHRodW1iU2l6ZT8uaGVpZ2h0KVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGdldFZpZXdwb3J0UHJvcHMoKSB7XG4gICAgICBjb25zdCBoYW5kbGVVc2VySW50ZXJhY3Rpb24gPSAoKSA9PiB7XG4gICAgICAgIHNlbmQoeyB0eXBlOiBcInVzZXIuc2Nyb2xsXCIgfSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIG5vcm1hbGl6ZS5lbGVtZW50KHtcbiAgICAgICAgLi4ucGFydHMudmlld3BvcnQuYXR0cnMsXG4gICAgICAgIHJvbGU6IFwicHJlc2VudGF0aW9uXCIsXG4gICAgICAgIFwiZGF0YS1vd25lZGJ5XCI6IGdldFJvb3RJZChzY29wZSksXG4gICAgICAgIGlkOiBnZXRWaWV3cG9ydElkKHNjb3BlKSxcbiAgICAgICAgXCJkYXRhLWF0LXRvcFwiOiBkYXRhQXR0cihhdFNpZGVzLnRvcCksXG4gICAgICAgIFwiZGF0YS1hdC1ib3R0b21cIjogZGF0YUF0dHIoYXRTaWRlcy5ib3R0b20pLFxuICAgICAgICBcImRhdGEtYXQtbGVmdFwiOiBkYXRhQXR0cihhdFNpZGVzLmxlZnQpLFxuICAgICAgICBcImRhdGEtYXQtcmlnaHRcIjogZGF0YUF0dHIoYXRTaWRlcy5yaWdodCksXG4gICAgICAgIFwiZGF0YS1vdmVyZmxvdy14XCI6IGRhdGFBdHRyKCFoaWRkZW5TdGF0ZS5zY3JvbGxiYXJYSGlkZGVuKSxcbiAgICAgICAgXCJkYXRhLW92ZXJmbG93LXlcIjogZGF0YUF0dHIoIWhpZGRlblN0YXRlLnNjcm9sbGJhcllIaWRkZW4pLFxuICAgICAgICB0YWJJbmRleDogaGlkZGVuU3RhdGUuc2Nyb2xsYmFyWEhpZGRlbiB8fCBoaWRkZW5TdGF0ZS5zY3JvbGxiYXJZSGlkZGVuID8gdm9pZCAwIDogMCxcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICBvdmVyZmxvdzogXCJhdXRvXCJcbiAgICAgICAgfSxcbiAgICAgICAgb25TY3JvbGwoZXZlbnQpIHtcbiAgICAgICAgICBzZW5kKHsgdHlwZTogXCJ2aWV3cG9ydC5zY3JvbGxcIiwgdGFyZ2V0OiBldmVudC5jdXJyZW50VGFyZ2V0IH0pO1xuICAgICAgICB9LFxuICAgICAgICBvbldoZWVsOiBoYW5kbGVVc2VySW50ZXJhY3Rpb24sXG4gICAgICAgIG9uVG91Y2hNb3ZlOiBoYW5kbGVVc2VySW50ZXJhY3Rpb24sXG4gICAgICAgIG9uUG9pbnRlck1vdmU6IGhhbmRsZVVzZXJJbnRlcmFjdGlvbixcbiAgICAgICAgb25Qb2ludGVyRW50ZXI6IGhhbmRsZVVzZXJJbnRlcmFjdGlvbixcbiAgICAgICAgb25LZXlEb3duOiBoYW5kbGVVc2VySW50ZXJhY3Rpb25cbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZ2V0Q29udGVudFByb3BzKCkge1xuICAgICAgcmV0dXJuIG5vcm1hbGl6ZS5lbGVtZW50KHtcbiAgICAgICAgLi4ucGFydHMuY29udGVudC5hdHRycyxcbiAgICAgICAgaWQ6IGdldENvbnRlbnRJZChzY29wZSksXG4gICAgICAgIHJvbGU6IFwicHJlc2VudGF0aW9uXCIsXG4gICAgICAgIFwiZGF0YS1vdmVyZmxvdy14XCI6IGRhdGFBdHRyKCFoaWRkZW5TdGF0ZS5zY3JvbGxiYXJYSGlkZGVuKSxcbiAgICAgICAgXCJkYXRhLW92ZXJmbG93LXlcIjogZGF0YUF0dHIoIWhpZGRlblN0YXRlLnNjcm9sbGJhcllIaWRkZW4pLFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIG1pbldpZHRoOiBcImZpdC1jb250ZW50XCJcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBnZXRTY3JvbGxiYXJQcm9wcyhwcm9wczIgPSB7fSkge1xuICAgICAgY29uc3QgeyBvcmllbnRhdGlvbiA9IFwidmVydGljYWxcIiB9ID0gcHJvcHMyO1xuICAgICAgcmV0dXJuIG5vcm1hbGl6ZS5lbGVtZW50KHtcbiAgICAgICAgLi4ucGFydHMuc2Nyb2xsYmFyLmF0dHJzLFxuICAgICAgICBcImRhdGEtb3duZWRieVwiOiBnZXRSb290SWQoc2NvcGUpLFxuICAgICAgICBcImRhdGEtb3JpZW50YXRpb25cIjogb3JpZW50YXRpb24sXG4gICAgICAgIFwiZGF0YS1zY3JvbGxpbmdcIjogZGF0YUF0dHIoY29udGV4dC5nZXQob3JpZW50YXRpb24gPT09IFwiaG9yaXpvbnRhbFwiID8gXCJzY3JvbGxpbmdYXCIgOiBcInNjcm9sbGluZ1lcIikpLFxuICAgICAgICBcImRhdGEtaG92ZXJcIjogZGF0YUF0dHIoY29udGV4dC5nZXQoXCJob3ZlcmluZ1wiKSksXG4gICAgICAgIFwiZGF0YS1vdmVyZmxvdy14XCI6IGRhdGFBdHRyKCFoaWRkZW5TdGF0ZS5zY3JvbGxiYXJYSGlkZGVuKSxcbiAgICAgICAgXCJkYXRhLW92ZXJmbG93LXlcIjogZGF0YUF0dHIoIWhpZGRlblN0YXRlLnNjcm9sbGJhcllIaWRkZW4pLFxuICAgICAgICBvblBvaW50ZXJVcCgpIHtcbiAgICAgICAgICBzZW5kKHsgdHlwZTogXCJzY3JvbGxiYXIucG9pbnRlcnVwXCIsIG9yaWVudGF0aW9uIH0pO1xuICAgICAgICB9LFxuICAgICAgICBvblBvaW50ZXJEb3duKGV2ZW50KSB7XG4gICAgICAgICAgaWYgKGV2ZW50LmJ1dHRvbiAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZXZlbnQuY3VycmVudFRhcmdldCAhPT0gZXZlbnQudGFyZ2V0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHBvaW50ID0gZ2V0RXZlbnRQb2ludChldmVudCk7XG4gICAgICAgICAgc2VuZCh7IHR5cGU6IFwic2Nyb2xsYmFyLnBvaW50ZXJkb3duXCIsIG9yaWVudGF0aW9uLCBwb2ludCB9KTtcbiAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfSxcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICAgIHRvdWNoQWN0aW9uOiBcIm5vbmVcIixcbiAgICAgICAgICBXZWJraXRVc2VyU2VsZWN0OiBcIm5vbmVcIixcbiAgICAgICAgICB1c2VyU2VsZWN0OiBcIm5vbmVcIixcbiAgICAgICAgICAuLi5vcmllbnRhdGlvbiA9PT0gXCJ2ZXJ0aWNhbFwiICYmIHtcbiAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgIGJvdHRvbTogYHZhcigtLWNvcmRlci1oZWlnaHQpYCxcbiAgICAgICAgICAgIGluc2V0SW5saW5lRW5kOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICAuLi5vcmllbnRhdGlvbiA9PT0gXCJob3Jpem9udGFsXCIgJiYge1xuICAgICAgICAgICAgaW5zZXRJbmxpbmVTdGFydDogMCxcbiAgICAgICAgICAgIGluc2V0SW5saW5lRW5kOiBgdmFyKC0tY29yZGVyLXdpZHRoKWAsXG4gICAgICAgICAgICBib3R0b206IDBcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZ2V0VGh1bWJQcm9wcyhwcm9wczIgPSB7fSkge1xuICAgICAgY29uc3QgeyBvcmllbnRhdGlvbiA9IFwidmVydGljYWxcIiB9ID0gcHJvcHMyO1xuICAgICAgcmV0dXJuIG5vcm1hbGl6ZS5lbGVtZW50KHtcbiAgICAgICAgLi4ucGFydHMudGh1bWIuYXR0cnMsXG4gICAgICAgIFwiZGF0YS1vd25lZGJ5XCI6IGdldFJvb3RJZChzY29wZSksXG4gICAgICAgIFwiZGF0YS1vcmllbnRhdGlvblwiOiBvcmllbnRhdGlvbixcbiAgICAgICAgb25Qb2ludGVyRG93bihldmVudCkge1xuICAgICAgICAgIGlmIChldmVudC5idXR0b24gIT09IDApIHJldHVybjtcbiAgICAgICAgICBjb25zdCBwb2ludCA9IGdldEV2ZW50UG9pbnQoZXZlbnQpO1xuICAgICAgICAgIHNlbmQoeyB0eXBlOiBcInRodW1iLnBvaW50ZXJkb3duXCIsIG9yaWVudGF0aW9uLCBwb2ludCB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAuLi5vcmllbnRhdGlvbiA9PT0gXCJ2ZXJ0aWNhbFwiICYmIHtcbiAgICAgICAgICAgIGhlaWdodDogXCJ2YXIoLS10aHVtYi1oZWlnaHQpXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIC4uLm9yaWVudGF0aW9uID09PSBcImhvcml6b250YWxcIiAmJiB7XG4gICAgICAgICAgICB3aWR0aDogXCJ2YXIoLS10aHVtYi13aWR0aClcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBnZXRDb3JuZXJQcm9wcygpIHtcbiAgICAgIHJldHVybiBub3JtYWxpemUuZWxlbWVudCh7XG4gICAgICAgIC4uLnBhcnRzLmNvcm5lci5hdHRycyxcbiAgICAgICAgXCJkYXRhLW93bmVkYnlcIjogZ2V0Um9vdElkKHNjb3BlKSxcbiAgICAgICAgXCJkYXRhLWhvdmVyXCI6IGRhdGFBdHRyKGNvbnRleHQuZ2V0KFwiaG92ZXJpbmdcIikpLFxuICAgICAgICBcImRhdGEtc3RhdGVcIjogaGlkZGVuU3RhdGUuY29ybmVySGlkZGVuID8gXCJoaWRkZW5cIiA6IFwidmlzaWJsZVwiLFxuICAgICAgICBcImRhdGEtb3ZlcmZsb3cteFwiOiBkYXRhQXR0cighaGlkZGVuU3RhdGUuc2Nyb2xsYmFyWEhpZGRlbiksXG4gICAgICAgIFwiZGF0YS1vdmVyZmxvdy15XCI6IGRhdGFBdHRyKCFoaWRkZW5TdGF0ZS5zY3JvbGxiYXJZSGlkZGVuKSxcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICAgIGJvdHRvbTogMCxcbiAgICAgICAgICBpbnNldElubGluZUVuZDogMCxcbiAgICAgICAgICB3aWR0aDogXCJ2YXIoLS1jb3JkZXItd2lkdGgpXCIsXG4gICAgICAgICAgaGVpZ2h0OiBcInZhcigtLWNvcmRlci1oZWlnaHQpXCJcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0U2Nyb2xsT2Zmc2V0KGVsZW1lbnQsIHByb3AsIGF4aXMpIHtcbiAgaWYgKCFlbGVtZW50KSByZXR1cm4gMDtcbiAgY29uc3Qgc3R5bGVzID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbiAgY29uc3Qgc3RhcnQgPSBheGlzID09PSBcInhcIiA/IFwiTGVmdFwiIDogXCJUb3BcIjtcbiAgY29uc3QgZW5kID0gYXhpcyA9PT0gXCJ4XCIgPyBcIlJpZ2h0XCIgOiBcIkJvdHRvbVwiO1xuICByZXR1cm4gcGFyc2VGbG9hdChzdHlsZXNbYCR7cHJvcH0ke3N0YXJ0fWBdKSArIHBhcnNlRmxvYXQoc3R5bGVzW2Ake3Byb3B9JHtlbmR9YF0pO1xufVxuXG4vLyBzcmMvdXRpbHMvc2Nyb2xsLXNpZGVzLnRzXG5mdW5jdGlvbiBnZXRTY3JvbGxTaWRlcyhub2RlLCBkaXIpIHtcbiAgY29uc3Qgc2Nyb2xsVG9wID0gbm9kZS5zY3JvbGxUb3A7XG4gIGNvbnN0IHNjcm9sbExlZnQgPSBub2RlLnNjcm9sbExlZnQ7XG4gIGNvbnN0IGlzUnRsID0gZGlyID09PSBcInJ0bFwiO1xuICBjb25zdCB0aHJlc2hvbGQgPSAxO1xuICBjb25zdCBoYXNWZXJ0aWNhbFNjcm9sbCA9IG5vZGUuc2Nyb2xsSGVpZ2h0IC0gbm9kZS5jbGllbnRIZWlnaHQgPiB0aHJlc2hvbGQ7XG4gIGNvbnN0IGhhc0hvcml6b250YWxTY3JvbGwgPSBub2RlLnNjcm9sbFdpZHRoIC0gbm9kZS5jbGllbnRXaWR0aCA+IHRocmVzaG9sZDtcbiAgY29uc3QgbWF4U2Nyb2xsTGVmdCA9IG5vZGUuc2Nyb2xsV2lkdGggLSBub2RlLmNsaWVudFdpZHRoO1xuICBjb25zdCBtYXhTY3JvbGxUb3AgPSBub2RlLnNjcm9sbEhlaWdodCAtIG5vZGUuY2xpZW50SGVpZ2h0O1xuICBsZXQgYXRMZWZ0ID0gZmFsc2U7XG4gIGxldCBhdFJpZ2h0ID0gZmFsc2U7XG4gIGxldCBhdFRvcCA9IGZhbHNlO1xuICBsZXQgYXRCb3R0b20gPSBmYWxzZTtcbiAgaWYgKGhhc0hvcml6b250YWxTY3JvbGwpIHtcbiAgICBpZiAoaXNSdGwpIHtcbiAgICAgIGlmIChzY3JvbGxMZWZ0IDw9IDApIHtcbiAgICAgICAgYXRMZWZ0ID0gTWF0aC5hYnMoc2Nyb2xsTGVmdCkgPj0gbWF4U2Nyb2xsTGVmdCAtIHRocmVzaG9sZDtcbiAgICAgICAgYXRSaWdodCA9IE1hdGguYWJzKHNjcm9sbExlZnQpIDw9IHRocmVzaG9sZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF0TGVmdCA9IHNjcm9sbExlZnQgPD0gdGhyZXNob2xkO1xuICAgICAgICBhdFJpZ2h0ID0gc2Nyb2xsTGVmdCA+PSBtYXhTY3JvbGxMZWZ0IC0gdGhyZXNob2xkO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBhdExlZnQgPSBzY3JvbGxMZWZ0IDw9IHRocmVzaG9sZDtcbiAgICAgIGF0UmlnaHQgPSBzY3JvbGxMZWZ0ID49IG1heFNjcm9sbExlZnQgLSB0aHJlc2hvbGQ7XG4gICAgfVxuICB9XG4gIGlmIChoYXNWZXJ0aWNhbFNjcm9sbCkge1xuICAgIGF0VG9wID0gc2Nyb2xsVG9wIDw9IHRocmVzaG9sZDtcbiAgICBhdEJvdHRvbSA9IHNjcm9sbFRvcCA+PSBtYXhTY3JvbGxUb3AgLSB0aHJlc2hvbGQ7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0b3A6IGF0VG9wLFxuICAgIHJpZ2h0OiBhdFJpZ2h0LFxuICAgIGJvdHRvbTogYXRCb3R0b20sXG4gICAgbGVmdDogYXRMZWZ0XG4gIH07XG59XG5cbi8vIHNyYy91dGlscy90aW1lb3V0LnRzXG52YXIgRU1QVFkgPSAwO1xudmFyIFRpbWVvdXQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJjdXJyZW50SWRcIiwgRU1QVFkpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJjbGVhclwiLCAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5jdXJyZW50SWQgIT09IEVNUFRZKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmN1cnJlbnRJZCk7XG4gICAgICAgIHRoaXMuY3VycmVudElkID0gRU1QVFk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImRpc3Bvc2VFZmZlY3RcIiwgKCkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMuY2xlYXI7XG4gICAgfSk7XG4gIH1cbiAgc3RhcnQoZGVsYXksIGZuKSB7XG4gICAgdGhpcy5jbGVhcigpO1xuICAgIHRoaXMuY3VycmVudElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLmN1cnJlbnRJZCA9IEVNUFRZO1xuICAgICAgZm4oKTtcbiAgICB9LCBkZWxheSk7XG4gIH1cbiAgaXNTdGFydGVkKCkge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRJZCAhPT0gRU1QVFk7XG4gIH1cbn07XG5cbi8vIHNyYy9zY3JvbGwtYXJlYS5tYWNoaW5lLnRzXG52YXIgTUlOX1RIVU1CX1NJWkUgPSAyMDtcbnZhciBTQ1JPTExfVElNRU9VVCA9IDFlMztcbnZhciBtYWNoaW5lID0gY3JlYXRlTWFjaGluZSh7XG4gIHByb3BzKHsgcHJvcHM6IHByb3BzMiB9KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiBcInN2XCIsXG4gICAgICAuLi5wcm9wczJcbiAgICB9O1xuICB9LFxuICBjb250ZXh0KHsgYmluZGFibGUgfSkge1xuICAgIHJldHVybiB7XG4gICAgICBzY3JvbGxpbmdYOiBiaW5kYWJsZSgoKSA9PiAoeyBkZWZhdWx0VmFsdWU6IGZhbHNlIH0pKSxcbiAgICAgIHNjcm9sbGluZ1k6IGJpbmRhYmxlKCgpID0+ICh7IGRlZmF1bHRWYWx1ZTogZmFsc2UgfSkpLFxuICAgICAgaG92ZXJpbmc6IGJpbmRhYmxlKCgpID0+ICh7IGRlZmF1bHRWYWx1ZTogZmFsc2UgfSkpLFxuICAgICAgdG91Y2hNb2RhbGl0eTogYmluZGFibGUoKCkgPT4gKHsgZGVmYXVsdFZhbHVlOiBmYWxzZSB9KSksXG4gICAgICBhdFNpZGVzOiBiaW5kYWJsZSgoKSA9PiAoe1xuICAgICAgICBkZWZhdWx0VmFsdWU6IHsgdG9wOiB0cnVlLCByaWdodDogZmFsc2UsIGJvdHRvbTogZmFsc2UsIGxlZnQ6IHRydWUgfVxuICAgICAgfSkpLFxuICAgICAgY29ybmVyU2l6ZTogYmluZGFibGUoKCkgPT4gKHtcbiAgICAgICAgZGVmYXVsdFZhbHVlOiB7IHdpZHRoOiAwLCBoZWlnaHQ6IDAgfVxuICAgICAgfSkpLFxuICAgICAgdGh1bWJTaXplOiBiaW5kYWJsZSgoKSA9PiAoe1xuICAgICAgICBkZWZhdWx0VmFsdWU6IHsgd2lkdGg6IDAsIGhlaWdodDogMCB9XG4gICAgICB9KSksXG4gICAgICBoaWRkZW5TdGF0ZTogYmluZGFibGUoKCkgPT4gKHtcbiAgICAgICAgZGVmYXVsdFZhbHVlOiB7XG4gICAgICAgICAgc2Nyb2xsYmFyWUhpZGRlbjogZmFsc2UsXG4gICAgICAgICAgc2Nyb2xsYmFyWEhpZGRlbjogZmFsc2UsXG4gICAgICAgICAgY29ybmVySGlkZGVuOiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICBoYXNoKGEpIHtcbiAgICAgICAgICByZXR1cm4gYFk6JHthLnNjcm9sbGJhcllIaWRkZW59IFg6JHthLnNjcm9sbGJhclhIaWRkZW59IEM6JHthLmNvcm5lckhpZGRlbn1gO1xuICAgICAgICB9XG4gICAgICB9KSlcbiAgICB9O1xuICB9LFxuICByZWZzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBvcmllbnRhdGlvbjogXCJ2ZXJ0aWNhbFwiLFxuICAgICAgc2Nyb2xsUG9zaXRpb246IHsgeDogMCwgeTogMCB9LFxuICAgICAgc2Nyb2xsWVRpbWVvdXQ6IG5ldyBUaW1lb3V0KCksXG4gICAgICBzY3JvbGxYVGltZW91dDogbmV3IFRpbWVvdXQoKSxcbiAgICAgIHNjcm9sbEVuZFRpbWVvdXQ6IG5ldyBUaW1lb3V0KCksXG4gICAgICBzdGFydFg6IDAsXG4gICAgICBzdGFydFk6IDAsXG4gICAgICBzdGFydFNjcm9sbFRvcDogMCxcbiAgICAgIHN0YXJ0U2Nyb2xsTGVmdDogMCxcbiAgICAgIHByb2dyYW1tYXRpY1Njcm9sbDogdHJ1ZVxuICAgIH07XG4gIH0sXG4gIGluaXRpYWxTdGF0ZSgpIHtcbiAgICByZXR1cm4gXCJpZGxlXCI7XG4gIH0sXG4gIHdhdGNoKHsgdHJhY2ssIHByb3AsIGNvbnRleHQsIHNlbmQgfSkge1xuICAgIHRyYWNrKFsoKSA9PiBwcm9wKFwiZGlyXCIpLCAoKSA9PiBjb250ZXh0Lmhhc2goXCJoaWRkZW5TdGF0ZVwiKV0sICgpID0+IHtcbiAgICAgIHNlbmQoeyB0eXBlOiBcInRodW1iLm1lYXN1cmVcIiB9KTtcbiAgICB9KTtcbiAgfSxcbiAgZWZmZWN0czogW1widHJhY2tDb250ZW50UmVzaXplXCIsIFwidHJhY2tWaWV3cG9ydFZpc2liaWxpdHlcIiwgXCJ0cmFja1doZWVsRXZlbnRcIl0sXG4gIGVudHJ5OiBbXCJjaGVja0hvdmVyaW5nXCJdLFxuICBleGl0OiBbXCJjbGVhclRpbWVvdXRzXCJdLFxuICBvbjoge1xuICAgIFwidGh1bWIubWVhc3VyZVwiOiB7XG4gICAgICBhY3Rpb25zOiBbXCJzZXRUaHVtYlNpemVcIl1cbiAgICB9LFxuICAgIFwidmlld3BvcnQuc2Nyb2xsXCI6IHtcbiAgICAgIGFjdGlvbnM6IFtcInNldFRodW1iU2l6ZVwiLCBcInNldFNjcm9sbGluZ1wiLCBcInNldFByb2dyYW1tYXRpY1Njcm9sbFwiXVxuICAgIH0sXG4gICAgXCJyb290LnBvaW50ZXJlbnRlclwiOiB7XG4gICAgICBhY3Rpb25zOiBbXCJzZXRUb3VjaE1vZGFsaXR5XCIsIFwic2V0SG92ZXJpbmdcIl1cbiAgICB9LFxuICAgIFwicm9vdC5wb2ludGVyZG93blwiOiB7XG4gICAgICBhY3Rpb25zOiBbXCJzZXRUb3VjaE1vZGFsaXR5XCJdXG4gICAgfSxcbiAgICBcInJvb3QucG9pbnRlcmxlYXZlXCI6IHtcbiAgICAgIGFjdGlvbnM6IFtcImNsZWFySG92ZXJpbmdcIl1cbiAgICB9XG4gIH0sXG4gIHN0YXRlczoge1xuICAgIGlkbGU6IHtcbiAgICAgIG9uOiB7XG4gICAgICAgIFwic2Nyb2xsYmFyLnBvaW50ZXJkb3duXCI6IHtcbiAgICAgICAgICB0YXJnZXQ6IFwiZHJhZ2dpbmdcIixcbiAgICAgICAgICBhY3Rpb25zOiBbXCJzY3JvbGxUb1BvaW50ZXJcIiwgXCJzdGFydERyYWdnaW5nXCJdXG4gICAgICAgIH0sXG4gICAgICAgIFwidGh1bWIucG9pbnRlcmRvd25cIjoge1xuICAgICAgICAgIHRhcmdldDogXCJkcmFnZ2luZ1wiLFxuICAgICAgICAgIGFjdGlvbnM6IFtcInN0YXJ0RHJhZ2dpbmdcIl1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZHJhZ2dpbmc6IHtcbiAgICAgIGVmZmVjdHM6IFtcInRyYWNrUG9pbnRlck1vdmVcIl0sXG4gICAgICBvbjoge1xuICAgICAgICBcInRodW1iLnBvaW50ZXJtb3ZlXCI6IHtcbiAgICAgICAgICBhY3Rpb25zOiBbXCJzZXREcmFnZ2luZ1Njcm9sbFwiXVxuICAgICAgICB9LFxuICAgICAgICBcInNjcm9sbGJhci5wb2ludGVydXBcIjoge1xuICAgICAgICAgIHRhcmdldDogXCJpZGxlXCIsXG4gICAgICAgICAgYWN0aW9uczogW1wic3RvcERyYWdnaW5nXCJdXG4gICAgICAgIH0sXG4gICAgICAgIFwidGh1bWIucG9pbnRlcnVwXCI6IHtcbiAgICAgICAgICB0YXJnZXQ6IFwiaWRsZVwiLFxuICAgICAgICAgIGFjdGlvbnM6IFtcImNsZWFyU2Nyb2xsaW5nXCIsIFwic3RvcERyYWdnaW5nXCJdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGltcGxlbWVudGF0aW9uczoge1xuICAgIGFjdGlvbnM6IHtcbiAgICAgIHNldFRvdWNoTW9kYWxpdHkoeyBjb250ZXh0LCBldmVudCB9KSB7XG4gICAgICAgIGNvbnRleHQuc2V0KFwidG91Y2hNb2RhbGl0eVwiLCBldmVudC5wb2ludGVyVHlwZSA9PT0gXCJ0b3VjaFwiKTtcbiAgICAgIH0sXG4gICAgICBzZXRIb3ZlcmluZyh7IGNvbnRleHQgfSkge1xuICAgICAgICBjb250ZXh0LnNldChcImhvdmVyaW5nXCIsIHRydWUpO1xuICAgICAgfSxcbiAgICAgIGNsZWFySG92ZXJpbmcoeyBjb250ZXh0IH0pIHtcbiAgICAgICAgY29udGV4dC5zZXQoXCJob3ZlcmluZ1wiLCBmYWxzZSk7XG4gICAgICB9LFxuICAgICAgc2V0UHJvZ3JhbW1hdGljU2Nyb2xsKHsgcmVmcyB9KSB7XG4gICAgICAgIGNvbnN0IHNjcm9sbEVuZFRpbWVvdXQgPSByZWZzLmdldChcInNjcm9sbEVuZFRpbWVvdXRcIik7XG4gICAgICAgIHNjcm9sbEVuZFRpbWVvdXQuc3RhcnQoMTAwLCAoKSA9PiB7XG4gICAgICAgICAgcmVmcy5zZXQoXCJwcm9ncmFtbWF0aWNTY3JvbGxcIiwgdHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGNsZWFyU2Nyb2xsaW5nKHsgY29udGV4dCwgZXZlbnQgfSkge1xuICAgICAgICBjb250ZXh0LnNldChldmVudC5vcmllbnRhdGlvbiA9PT0gXCJ2ZXJ0aWNhbFwiID8gXCJzY3JvbGxpbmdZXCIgOiBcInNjcm9sbGluZ1hcIiwgZmFsc2UpO1xuICAgICAgfSxcbiAgICAgIHNldFRodW1iU2l6ZSh7IGNvbnRleHQsIHNjb3BlLCBwcm9wIH0pIHtcbiAgICAgICAgY29uc3Qgdmlld3BvcnRFbCA9IGdldFZpZXdwb3J0RWwoc2NvcGUpO1xuICAgICAgICBpZiAoIXZpZXdwb3J0RWwpIHJldHVybjtcbiAgICAgICAgY29uc3Qgc2Nyb2xsYWJsZUNvbnRlbnRIZWlnaHQgPSB2aWV3cG9ydEVsLnNjcm9sbEhlaWdodDtcbiAgICAgICAgY29uc3Qgc2Nyb2xsYWJsZUNvbnRlbnRXaWR0aCA9IHZpZXdwb3J0RWwuc2Nyb2xsV2lkdGg7XG4gICAgICAgIGlmIChzY3JvbGxhYmxlQ29udGVudEhlaWdodCA9PT0gMCB8fCBzY3JvbGxhYmxlQ29udGVudFdpZHRoID09PSAwKSByZXR1cm47XG4gICAgICAgIGNvbnN0IHNjcm9sbGJhcllFbCA9IGdldFNjcm9sbGJhcllFbChzY29wZSk7XG4gICAgICAgIGNvbnN0IHNjcm9sbGJhclhFbCA9IGdldFNjcm9sbGJhclhFbChzY29wZSk7XG4gICAgICAgIGNvbnN0IHRodW1iWUVsID0gZ2V0VGh1bWJZRWwoc2NvcGUpO1xuICAgICAgICBjb25zdCB0aHVtYlhFbCA9IGdldFRodW1iWEVsKHNjb3BlKTtcbiAgICAgICAgY29uc3Qgdmlld3BvcnRIZWlnaHQgPSB2aWV3cG9ydEVsLmNsaWVudEhlaWdodDtcbiAgICAgICAgY29uc3Qgdmlld3BvcnRXaWR0aCA9IHZpZXdwb3J0RWwuY2xpZW50V2lkdGg7XG4gICAgICAgIGNvbnN0IHNjcm9sbFRvcCA9IHZpZXdwb3J0RWwuc2Nyb2xsVG9wO1xuICAgICAgICBjb25zdCBzY3JvbGxMZWZ0ID0gdmlld3BvcnRFbC5zY3JvbGxMZWZ0O1xuICAgICAgICBjb25zdCBzY3JvbGxiYXJZSGlkZGVuID0gdmlld3BvcnRIZWlnaHQgPj0gc2Nyb2xsYWJsZUNvbnRlbnRIZWlnaHQ7XG4gICAgICAgIGNvbnN0IHNjcm9sbGJhclhIaWRkZW4gPSB2aWV3cG9ydFdpZHRoID49IHNjcm9sbGFibGVDb250ZW50V2lkdGg7XG4gICAgICAgIGNvbnN0IHJhdGlvWCA9IHZpZXdwb3J0V2lkdGggLyBzY3JvbGxhYmxlQ29udGVudFdpZHRoO1xuICAgICAgICBjb25zdCByYXRpb1kgPSB2aWV3cG9ydEhlaWdodCAvIHNjcm9sbGFibGVDb250ZW50SGVpZ2h0O1xuICAgICAgICBjb25zdCBuZXh0V2lkdGggPSBzY3JvbGxiYXJYSGlkZGVuID8gMCA6IHZpZXdwb3J0V2lkdGg7XG4gICAgICAgIGNvbnN0IG5leHRIZWlnaHQgPSBzY3JvbGxiYXJZSGlkZGVuID8gMCA6IHZpZXdwb3J0SGVpZ2h0O1xuICAgICAgICBjb25zdCBzY3JvbGxiYXJYT2Zmc2V0ID0gZ2V0U2Nyb2xsT2Zmc2V0KHNjcm9sbGJhclhFbCwgXCJwYWRkaW5nXCIsIFwieFwiKTtcbiAgICAgICAgY29uc3Qgc2Nyb2xsYmFyWU9mZnNldCA9IGdldFNjcm9sbE9mZnNldChzY3JvbGxiYXJZRWwsIFwicGFkZGluZ1wiLCBcInlcIik7XG4gICAgICAgIGNvbnN0IHRodW1iWE9mZnNldCA9IGdldFNjcm9sbE9mZnNldCh0aHVtYlhFbCwgXCJtYXJnaW5cIiwgXCJ4XCIpO1xuICAgICAgICBjb25zdCB0aHVtYllPZmZzZXQgPSBnZXRTY3JvbGxPZmZzZXQodGh1bWJZRWwsIFwibWFyZ2luXCIsIFwieVwiKTtcbiAgICAgICAgY29uc3QgaWRlYWxOZXh0V2lkdGggPSBuZXh0V2lkdGggLSBzY3JvbGxiYXJYT2Zmc2V0IC0gdGh1bWJYT2Zmc2V0O1xuICAgICAgICBjb25zdCBpZGVhbE5leHRIZWlnaHQgPSBuZXh0SGVpZ2h0IC0gc2Nyb2xsYmFyWU9mZnNldCAtIHRodW1iWU9mZnNldDtcbiAgICAgICAgY29uc3QgbWF4TmV4dFdpZHRoID0gc2Nyb2xsYmFyWEVsID8gTWF0aC5taW4oc2Nyb2xsYmFyWEVsLm9mZnNldFdpZHRoLCBpZGVhbE5leHRXaWR0aCkgOiBpZGVhbE5leHRXaWR0aDtcbiAgICAgICAgY29uc3QgbWF4TmV4dEhlaWdodCA9IHNjcm9sbGJhcllFbCA/IE1hdGgubWluKHNjcm9sbGJhcllFbC5vZmZzZXRIZWlnaHQsIGlkZWFsTmV4dEhlaWdodCkgOiBpZGVhbE5leHRIZWlnaHQ7XG4gICAgICAgIGNvbnN0IGNsYW1wZWROZXh0V2lkdGggPSBNYXRoLm1heChNSU5fVEhVTUJfU0laRSwgbWF4TmV4dFdpZHRoICogcmF0aW9YKTtcbiAgICAgICAgY29uc3QgY2xhbXBlZE5leHRIZWlnaHQgPSBNYXRoLm1heChNSU5fVEhVTUJfU0laRSwgbWF4TmV4dEhlaWdodCAqIHJhdGlvWSk7XG4gICAgICAgIGNvbnRleHQuc2V0KFwidGh1bWJTaXplXCIsIChwcmV2U2l6ZSkgPT4ge1xuICAgICAgICAgIGlmIChwcmV2U2l6ZS5oZWlnaHQgPT09IGNsYW1wZWROZXh0SGVpZ2h0ICYmIHByZXZTaXplLndpZHRoID09PSBjbGFtcGVkTmV4dFdpZHRoKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJldlNpemU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3aWR0aDogY2xhbXBlZE5leHRXaWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogY2xhbXBlZE5leHRIZWlnaHRcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHNjcm9sbGJhcllFbCAmJiB0aHVtYllFbCkge1xuICAgICAgICAgIGNvbnN0IG1heFRodW1iT2Zmc2V0WSA9IHNjcm9sbGJhcllFbC5vZmZzZXRIZWlnaHQgLSBjbGFtcGVkTmV4dEhlaWdodCAtIHNjcm9sbGJhcllPZmZzZXQgLSB0aHVtYllPZmZzZXQ7XG4gICAgICAgICAgY29uc3Qgc2Nyb2xsUmF0aW9ZID0gc2Nyb2xsVG9wIC8gKHNjcm9sbGFibGVDb250ZW50SGVpZ2h0IC0gdmlld3BvcnRIZWlnaHQpO1xuICAgICAgICAgIGNvbnN0IHRodW1iT2Zmc2V0WSA9IE1hdGgubWluKG1heFRodW1iT2Zmc2V0WSwgTWF0aC5tYXgoMCwgc2Nyb2xsUmF0aW9ZICogbWF4VGh1bWJPZmZzZXRZKSk7XG4gICAgICAgICAgdGh1bWJZRWwuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZTNkKDAsJHt0aHVtYk9mZnNldFl9cHgsMClgO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY3JvbGxiYXJYRWwgJiYgdGh1bWJYRWwpIHtcbiAgICAgICAgICBjb25zdCBtYXhUaHVtYk9mZnNldFggPSBzY3JvbGxiYXJYRWwub2Zmc2V0V2lkdGggLSBjbGFtcGVkTmV4dFdpZHRoIC0gc2Nyb2xsYmFyWE9mZnNldCAtIHRodW1iWE9mZnNldDtcbiAgICAgICAgICBjb25zdCBzY3JvbGxSYXRpb1ggPSBzY3JvbGxMZWZ0IC8gKHNjcm9sbGFibGVDb250ZW50V2lkdGggLSB2aWV3cG9ydFdpZHRoKTtcbiAgICAgICAgICBjb25zdCB0aHVtYk9mZnNldFggPSBwcm9wKFwiZGlyXCIpID09PSBcInJ0bFwiID8gY2xhbXBWYWx1ZShzY3JvbGxSYXRpb1ggKiBtYXhUaHVtYk9mZnNldFgsIC1tYXhUaHVtYk9mZnNldFgsIDApIDogY2xhbXBWYWx1ZShzY3JvbGxSYXRpb1ggKiBtYXhUaHVtYk9mZnNldFgsIDAsIG1heFRodW1iT2Zmc2V0WCk7XG4gICAgICAgICAgdGh1bWJYRWwuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZTNkKCR7dGh1bWJPZmZzZXRYfXB4LDAsMClgO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvcm5lckVsID0gZ2V0Q29ybmVyRWwoc2NvcGUpO1xuICAgICAgICBpZiAoY29ybmVyRWwpIHtcbiAgICAgICAgICBpZiAoc2Nyb2xsYmFyWEhpZGRlbiB8fCBzY3JvbGxiYXJZSGlkZGVuKSB7XG4gICAgICAgICAgICBjb250ZXh0LnNldChcImNvcm5lclNpemVcIiwgeyB3aWR0aDogMCwgaGVpZ2h0OiAwIH0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIXNjcm9sbGJhclhIaWRkZW4gJiYgIXNjcm9sbGJhcllIaWRkZW4pIHtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gc2Nyb2xsYmFyWUVsPy5vZmZzZXRXaWR0aCB8fCAwO1xuICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gc2Nyb2xsYmFyWEVsPy5vZmZzZXRIZWlnaHQgfHwgMDtcbiAgICAgICAgICAgIGNvbnRleHQuc2V0KFwiY29ybmVyU2l6ZVwiLCB7IHdpZHRoLCBoZWlnaHQgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQuc2V0KFwiaGlkZGVuU3RhdGVcIiwgKHByZXZTdGF0ZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGNvcm5lckhpZGRlbiA9IHNjcm9sbGJhcllIaWRkZW4gfHwgc2Nyb2xsYmFyWEhpZGRlbjtcbiAgICAgICAgICBpZiAocHJldlN0YXRlLnNjcm9sbGJhcllIaWRkZW4gPT09IHNjcm9sbGJhcllIaWRkZW4gJiYgcHJldlN0YXRlLnNjcm9sbGJhclhIaWRkZW4gPT09IHNjcm9sbGJhclhIaWRkZW4gJiYgcHJldlN0YXRlLmNvcm5lckhpZGRlbiA9PT0gY29ybmVySGlkZGVuKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJldlN0YXRlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2Nyb2xsYmFyWUhpZGRlbixcbiAgICAgICAgICAgIHNjcm9sbGJhclhIaWRkZW4sXG4gICAgICAgICAgICBjb3JuZXJIaWRkZW5cbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgY29udGV4dC5zZXQoXCJhdFNpZGVzXCIsIChwcmV2KSA9PiB7XG4gICAgICAgICAgY29uc3QgbmV4dCA9IGdldFNjcm9sbFNpZGVzKHZpZXdwb3J0RWwsIHByb3AoXCJkaXJcIikpO1xuICAgICAgICAgIGlmIChpc0VxdWFsKHByZXYsIG5leHQpKSByZXR1cm4gcHJldjtcbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgY2hlY2tIb3ZlcmluZyh7IHNjb3BlLCBjb250ZXh0IH0pIHtcbiAgICAgICAgY29uc3Qgdmlld3BvcnRFbCA9IGdldFZpZXdwb3J0RWwoc2NvcGUpO1xuICAgICAgICBpZiAodmlld3BvcnRFbD8ubWF0Y2hlcyhcIjpob3ZlclwiKSkge1xuICAgICAgICAgIGNvbnRleHQuc2V0KFwiaG92ZXJpbmdcIiwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzZXRTY3JvbGxpbmcoeyBldmVudCwgcmVmcywgY29udGV4dCwgcHJvcCB9KSB7XG4gICAgICAgIGNvbnN0IHNjcm9sbFBvc2l0aW9uID0ge1xuICAgICAgICAgIHg6IGV2ZW50LnRhcmdldC5zY3JvbGxMZWZ0LFxuICAgICAgICAgIHk6IGV2ZW50LnRhcmdldC5zY3JvbGxUb3BcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc2Nyb2xsUG9zaXRpb25SZWYgPSByZWZzLmdldChcInNjcm9sbFBvc2l0aW9uXCIpO1xuICAgICAgICBjb25zdCBvZmZzZXRYID0gc2Nyb2xsUG9zaXRpb24ueCAtIHNjcm9sbFBvc2l0aW9uUmVmLng7XG4gICAgICAgIGNvbnN0IG9mZnNldFkgPSBzY3JvbGxQb3NpdGlvbi55IC0gc2Nyb2xsUG9zaXRpb25SZWYueTtcbiAgICAgICAgcmVmcy5zZXQoXCJzY3JvbGxQb3NpdGlvblwiLCBzY3JvbGxQb3NpdGlvbik7XG4gICAgICAgIGNvbnRleHQuc2V0KFwiYXRTaWRlc1wiLCAocHJldikgPT4ge1xuICAgICAgICAgIGNvbnN0IG5leHQgPSBnZXRTY3JvbGxTaWRlcyhldmVudC50YXJnZXQsIHByb3AoXCJkaXJcIikpO1xuICAgICAgICAgIGlmIChpc0VxdWFsKHByZXYsIG5leHQpKSByZXR1cm4gcHJldjtcbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChvZmZzZXRZICE9PSAwKSB7XG4gICAgICAgICAgY29udGV4dC5zZXQoXCJzY3JvbGxpbmdZXCIsIHRydWUpO1xuICAgICAgICAgIHJlZnMuZ2V0KFwic2Nyb2xsWVRpbWVvdXRcIikuc3RhcnQoU0NST0xMX1RJTUVPVVQsICgpID0+IHtcbiAgICAgICAgICAgIGNvbnRleHQuc2V0KFwic2Nyb2xsaW5nWVwiLCBmYWxzZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9mZnNldFggIT09IDApIHtcbiAgICAgICAgICBjb250ZXh0LnNldChcInNjcm9sbGluZ1hcIiwgdHJ1ZSk7XG4gICAgICAgICAgcmVmcy5nZXQoXCJzY3JvbGxYVGltZW91dFwiKS5zdGFydChTQ1JPTExfVElNRU9VVCwgKCkgPT4ge1xuICAgICAgICAgICAgY29udGV4dC5zZXQoXCJzY3JvbGxpbmdYXCIsIGZhbHNlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNjcm9sbFRvUG9pbnRlcih7IGV2ZW50LCBzY29wZSwgcHJvcCB9KSB7XG4gICAgICAgIGNvbnN0IHZpZXdwb3J0RWwgPSBnZXRWaWV3cG9ydEVsKHNjb3BlKTtcbiAgICAgICAgaWYgKCF2aWV3cG9ydEVsKSByZXR1cm47XG4gICAgICAgIGNvbnN0IHRodW1iWVJlZiA9IGdldFRodW1iWUVsKHNjb3BlKTtcbiAgICAgICAgY29uc3Qgc2Nyb2xsYmFyWVJlZiA9IGdldFNjcm9sbGJhcllFbChzY29wZSk7XG4gICAgICAgIGNvbnN0IHRodW1iWFJlZiA9IGdldFRodW1iWEVsKHNjb3BlKTtcbiAgICAgICAgY29uc3Qgc2Nyb2xsYmFyWFJlZiA9IGdldFNjcm9sbGJhclhFbChzY29wZSk7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGV2ZW50LnBvaW50O1xuICAgICAgICBpZiAodGh1bWJZUmVmICYmIHNjcm9sbGJhcllSZWYgJiYgZXZlbnQub3JpZW50YXRpb24gPT09IFwidmVydGljYWxcIikge1xuICAgICAgICAgIGNvbnN0IHRodW1iWU9mZnNldCA9IGdldFNjcm9sbE9mZnNldCh0aHVtYllSZWYsIFwibWFyZ2luXCIsIFwieVwiKTtcbiAgICAgICAgICBjb25zdCBzY3JvbGxiYXJZT2Zmc2V0ID0gZ2V0U2Nyb2xsT2Zmc2V0KHNjcm9sbGJhcllSZWYsIFwicGFkZGluZ1wiLCBcInlcIik7XG4gICAgICAgICAgY29uc3QgdGh1bWJIZWlnaHQgPSB0aHVtYllSZWYub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgIGNvbnN0IHRyYWNrUmVjdFkgPSBzY3JvbGxiYXJZUmVmLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgIGNvbnN0IGNsaWNrWSA9IGNsaWVudC55IC0gdHJhY2tSZWN0WS50b3AgLSB0aHVtYkhlaWdodCAvIDIgLSBzY3JvbGxiYXJZT2Zmc2V0ICsgdGh1bWJZT2Zmc2V0IC8gMjtcbiAgICAgICAgICBjb25zdCBzY3JvbGxhYmxlQ29udGVudEhlaWdodCA9IHZpZXdwb3J0RWwuc2Nyb2xsSGVpZ2h0O1xuICAgICAgICAgIGNvbnN0IHZpZXdwb3J0SGVpZ2h0ID0gdmlld3BvcnRFbC5jbGllbnRIZWlnaHQ7XG4gICAgICAgICAgY29uc3QgbWF4VGh1bWJPZmZzZXRZID0gc2Nyb2xsYmFyWVJlZi5vZmZzZXRIZWlnaHQgLSB0aHVtYkhlaWdodCAtIHNjcm9sbGJhcllPZmZzZXQgLSB0aHVtYllPZmZzZXQ7XG4gICAgICAgICAgY29uc3Qgc2Nyb2xsUmF0aW9ZID0gY2xpY2tZIC8gbWF4VGh1bWJPZmZzZXRZO1xuICAgICAgICAgIGNvbnN0IG5ld1Njcm9sbFRvcCA9IHNjcm9sbFJhdGlvWSAqIChzY3JvbGxhYmxlQ29udGVudEhlaWdodCAtIHZpZXdwb3J0SGVpZ2h0KTtcbiAgICAgICAgICB2aWV3cG9ydEVsLnNjcm9sbFRvcCA9IG5ld1Njcm9sbFRvcDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGh1bWJYUmVmICYmIHNjcm9sbGJhclhSZWYgJiYgZXZlbnQub3JpZW50YXRpb24gPT09IFwiaG9yaXpvbnRhbFwiKSB7XG4gICAgICAgICAgY29uc3QgdGh1bWJYT2Zmc2V0ID0gZ2V0U2Nyb2xsT2Zmc2V0KHRodW1iWFJlZiwgXCJtYXJnaW5cIiwgXCJ4XCIpO1xuICAgICAgICAgIGNvbnN0IHNjcm9sbGJhclhPZmZzZXQgPSBnZXRTY3JvbGxPZmZzZXQoc2Nyb2xsYmFyWFJlZiwgXCJwYWRkaW5nXCIsIFwieFwiKTtcbiAgICAgICAgICBjb25zdCB0aHVtYldpZHRoID0gdGh1bWJYUmVmLm9mZnNldFdpZHRoO1xuICAgICAgICAgIGNvbnN0IHRyYWNrUmVjdFggPSBzY3JvbGxiYXJYUmVmLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgIGNvbnN0IGNsaWNrWCA9IGNsaWVudC54IC0gdHJhY2tSZWN0WC5sZWZ0IC0gdGh1bWJXaWR0aCAvIDIgLSBzY3JvbGxiYXJYT2Zmc2V0ICsgdGh1bWJYT2Zmc2V0IC8gMjtcbiAgICAgICAgICBjb25zdCBzY3JvbGxhYmxlQ29udGVudFdpZHRoID0gdmlld3BvcnRFbC5zY3JvbGxXaWR0aDtcbiAgICAgICAgICBjb25zdCB2aWV3cG9ydFdpZHRoID0gdmlld3BvcnRFbC5jbGllbnRXaWR0aDtcbiAgICAgICAgICBjb25zdCBtYXhUaHVtYk9mZnNldFggPSBzY3JvbGxiYXJYUmVmLm9mZnNldFdpZHRoIC0gdGh1bWJXaWR0aCAtIHNjcm9sbGJhclhPZmZzZXQgLSB0aHVtYlhPZmZzZXQ7XG4gICAgICAgICAgY29uc3Qgc2Nyb2xsUmF0aW9YID0gY2xpY2tYIC8gbWF4VGh1bWJPZmZzZXRYO1xuICAgICAgICAgIGxldCBuZXdTY3JvbGxMZWZ0O1xuICAgICAgICAgIGlmIChwcm9wKFwiZGlyXCIpID09PSBcInJ0bFwiKSB7XG4gICAgICAgICAgICBuZXdTY3JvbGxMZWZ0ID0gKDEgLSBzY3JvbGxSYXRpb1gpICogKHNjcm9sbGFibGVDb250ZW50V2lkdGggLSB2aWV3cG9ydFdpZHRoKTtcbiAgICAgICAgICAgIGlmICh2aWV3cG9ydEVsLnNjcm9sbExlZnQgPD0gMCkge1xuICAgICAgICAgICAgICBuZXdTY3JvbGxMZWZ0ID0gLW5ld1Njcm9sbExlZnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld1Njcm9sbExlZnQgPSBzY3JvbGxSYXRpb1ggKiAoc2Nyb2xsYWJsZUNvbnRlbnRXaWR0aCAtIHZpZXdwb3J0V2lkdGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2aWV3cG9ydEVsLnNjcm9sbExlZnQgPSBuZXdTY3JvbGxMZWZ0O1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc3RhcnREcmFnZ2luZyh7IGV2ZW50LCByZWZzLCBzY29wZSB9KSB7XG4gICAgICAgIHJlZnMuc2V0KFwic3RhcnRYXCIsIGV2ZW50LnBvaW50LngpO1xuICAgICAgICByZWZzLnNldChcInN0YXJ0WVwiLCBldmVudC5wb2ludC55KTtcbiAgICAgICAgcmVmcy5zZXQoXCJvcmllbnRhdGlvblwiLCBldmVudC5vcmllbnRhdGlvbik7XG4gICAgICAgIGNvbnN0IHZpZXdwb3J0RWwgPSBnZXRWaWV3cG9ydEVsKHNjb3BlKTtcbiAgICAgICAgaWYgKCF2aWV3cG9ydEVsKSByZXR1cm47XG4gICAgICAgIHJlZnMuc2V0KFwic3RhcnRTY3JvbGxUb3BcIiwgdmlld3BvcnRFbC5zY3JvbGxUb3ApO1xuICAgICAgICByZWZzLnNldChcInN0YXJ0U2Nyb2xsTGVmdFwiLCB2aWV3cG9ydEVsLnNjcm9sbExlZnQpO1xuICAgICAgfSxcbiAgICAgIHNldERyYWdnaW5nU2Nyb2xsKHsgZXZlbnQsIHJlZnMsIHNjb3BlLCBjb250ZXh0IH0pIHtcbiAgICAgICAgY29uc3Qgc3RhcnRZID0gcmVmcy5nZXQoXCJzdGFydFlcIik7XG4gICAgICAgIGNvbnN0IHN0YXJ0WCA9IHJlZnMuZ2V0KFwic3RhcnRYXCIpO1xuICAgICAgICBjb25zdCBzdGFydFNjcm9sbFRvcCA9IHJlZnMuZ2V0KFwic3RhcnRTY3JvbGxUb3BcIik7XG4gICAgICAgIGNvbnN0IHN0YXJ0U2Nyb2xsTGVmdCA9IHJlZnMuZ2V0KFwic3RhcnRTY3JvbGxMZWZ0XCIpO1xuICAgICAgICBjb25zdCBjbGllbnQgPSBldmVudC5wb2ludDtcbiAgICAgICAgY29uc3QgZGVsdGFZID0gY2xpZW50LnkgLSBzdGFydFk7XG4gICAgICAgIGNvbnN0IGRlbHRhWCA9IGNsaWVudC54IC0gc3RhcnRYO1xuICAgICAgICBjb25zdCB2aWV3cG9ydEVsID0gZ2V0Vmlld3BvcnRFbChzY29wZSk7XG4gICAgICAgIGlmICghdmlld3BvcnRFbCkgcmV0dXJuO1xuICAgICAgICBjb25zdCBzY3JvbGxhYmxlQ29udGVudEhlaWdodCA9IHZpZXdwb3J0RWwuc2Nyb2xsSGVpZ2h0O1xuICAgICAgICBjb25zdCB2aWV3cG9ydEhlaWdodCA9IHZpZXdwb3J0RWwuY2xpZW50SGVpZ2h0O1xuICAgICAgICBjb25zdCBzY3JvbGxhYmxlQ29udGVudFdpZHRoID0gdmlld3BvcnRFbC5zY3JvbGxXaWR0aDtcbiAgICAgICAgY29uc3Qgdmlld3BvcnRXaWR0aCA9IHZpZXdwb3J0RWwuY2xpZW50V2lkdGg7XG4gICAgICAgIGNvbnN0IG9yaWVudGF0aW9uID0gcmVmcy5nZXQoXCJvcmllbnRhdGlvblwiKTtcbiAgICAgICAgY29uc3QgdGh1bWJZRWwgPSBnZXRUaHVtYllFbChzY29wZSk7XG4gICAgICAgIGNvbnN0IHNjcm9sbGJhcllFbCA9IGdldFNjcm9sbGJhcllFbChzY29wZSk7XG4gICAgICAgIGlmICh0aHVtYllFbCAmJiBzY3JvbGxiYXJZRWwgJiYgb3JpZW50YXRpb24gPT09IFwidmVydGljYWxcIikge1xuICAgICAgICAgIGNvbnN0IHNjcm9sbGJhcllPZmZzZXQgPSBnZXRTY3JvbGxPZmZzZXQoc2Nyb2xsYmFyWUVsLCBcInBhZGRpbmdcIiwgXCJ5XCIpO1xuICAgICAgICAgIGNvbnN0IHRodW1iWU9mZnNldCA9IGdldFNjcm9sbE9mZnNldCh0aHVtYllFbCwgXCJtYXJnaW5cIiwgXCJ5XCIpO1xuICAgICAgICAgIGNvbnN0IHRodW1iSGVpZ2h0ID0gdGh1bWJZRWwub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgIGNvbnN0IG1heFRodW1iT2Zmc2V0WSA9IHNjcm9sbGJhcllFbC5vZmZzZXRIZWlnaHQgLSB0aHVtYkhlaWdodCAtIHNjcm9sbGJhcllPZmZzZXQgLSB0aHVtYllPZmZzZXQ7XG4gICAgICAgICAgY29uc3Qgc2Nyb2xsUmF0aW9ZID0gZGVsdGFZIC8gbWF4VGh1bWJPZmZzZXRZO1xuICAgICAgICAgIHZpZXdwb3J0RWwuc2Nyb2xsVG9wID0gc3RhcnRTY3JvbGxUb3AgKyBzY3JvbGxSYXRpb1kgKiAoc2Nyb2xsYWJsZUNvbnRlbnRIZWlnaHQgLSB2aWV3cG9ydEhlaWdodCk7XG4gICAgICAgICAgY29udGV4dC5zZXQoXCJzY3JvbGxpbmdZXCIsIHRydWUpO1xuICAgICAgICAgIHJlZnMuZ2V0KFwic2Nyb2xsWVRpbWVvdXRcIikuc3RhcnQoU0NST0xMX1RJTUVPVVQsICgpID0+IHtcbiAgICAgICAgICAgIGNvbnRleHQuc2V0KFwic2Nyb2xsaW5nWVwiLCBmYWxzZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGh1bWJYRWwgPSBnZXRUaHVtYlhFbChzY29wZSk7XG4gICAgICAgIGNvbnN0IHNjcm9sbGJhclhFbCA9IGdldFNjcm9sbGJhclhFbChzY29wZSk7XG4gICAgICAgIGlmICh0aHVtYlhFbCAmJiBzY3JvbGxiYXJYRWwgJiYgb3JpZW50YXRpb24gPT09IFwiaG9yaXpvbnRhbFwiKSB7XG4gICAgICAgICAgY29uc3Qgc2Nyb2xsYmFyWE9mZnNldCA9IGdldFNjcm9sbE9mZnNldChzY3JvbGxiYXJYRWwsIFwicGFkZGluZ1wiLCBcInhcIik7XG4gICAgICAgICAgY29uc3QgdGh1bWJYT2Zmc2V0ID0gZ2V0U2Nyb2xsT2Zmc2V0KHRodW1iWEVsLCBcIm1hcmdpblwiLCBcInhcIik7XG4gICAgICAgICAgY29uc3QgdGh1bWJXaWR0aCA9IHRodW1iWEVsLm9mZnNldFdpZHRoO1xuICAgICAgICAgIGNvbnN0IG1heFRodW1iT2Zmc2V0WCA9IHNjcm9sbGJhclhFbC5vZmZzZXRXaWR0aCAtIHRodW1iV2lkdGggLSBzY3JvbGxiYXJYT2Zmc2V0IC0gdGh1bWJYT2Zmc2V0O1xuICAgICAgICAgIGNvbnN0IHNjcm9sbFJhdGlvWCA9IGRlbHRhWCAvIG1heFRodW1iT2Zmc2V0WDtcbiAgICAgICAgICB2aWV3cG9ydEVsLnNjcm9sbExlZnQgPSBzdGFydFNjcm9sbExlZnQgKyBzY3JvbGxSYXRpb1ggKiAoc2Nyb2xsYWJsZUNvbnRlbnRXaWR0aCAtIHZpZXdwb3J0V2lkdGgpO1xuICAgICAgICAgIGNvbnRleHQuc2V0KFwic2Nyb2xsaW5nWFwiLCB0cnVlKTtcbiAgICAgICAgICByZWZzLmdldChcInNjcm9sbFhUaW1lb3V0XCIpLnN0YXJ0KFNDUk9MTF9USU1FT1VULCAoKSA9PiB7XG4gICAgICAgICAgICBjb250ZXh0LnNldChcInNjcm9sbGluZ1hcIiwgZmFsc2UpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc3RvcERyYWdnaW5nKHsgcmVmcyB9KSB7XG4gICAgICAgIHJlZnMuc2V0KFwib3JpZW50YXRpb25cIiwgbnVsbCk7XG4gICAgICB9LFxuICAgICAgY2xlYXJUaW1lb3V0cyh7IHJlZnMgfSkge1xuICAgICAgICByZWZzLmdldChcInNjcm9sbFlUaW1lb3V0XCIpLmNsZWFyKCk7XG4gICAgICAgIHJlZnMuZ2V0KFwic2Nyb2xsWFRpbWVvdXRcIikuY2xlYXIoKTtcbiAgICAgICAgcmVmcy5nZXQoXCJzY3JvbGxFbmRUaW1lb3V0XCIpLmNsZWFyKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBlZmZlY3RzOiB7XG4gICAgICB0cmFja0NvbnRlbnRSZXNpemUoeyBzY29wZSwgc2VuZCB9KSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnRFbCA9IGdldENvbnRlbnRFbChzY29wZSk7XG4gICAgICAgIGlmICghY29udGVudEVsKSByZXR1cm47XG4gICAgICAgIGNvbnN0IHdpbiA9IHNjb3BlLmdldFdpbigpO1xuICAgICAgICBjb25zdCBvYnMgPSBuZXcgd2luLlJlc2l6ZU9ic2VydmVyKCgpID0+IHtcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHNlbmQoeyB0eXBlOiBcInRodW1iLm1lYXN1cmVcIiB9KTtcbiAgICAgICAgICB9LCAxKTtcbiAgICAgICAgfSk7XG4gICAgICAgIG9icy5vYnNlcnZlKGNvbnRlbnRFbCk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgb2JzLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICB0cmFja1ZpZXdwb3J0VmlzaWJpbGl0eSh7IHNjb3BlLCBzZW5kIH0pIHtcbiAgICAgICAgY29uc3Qgd2luID0gc2NvcGUuZ2V0V2luKCk7XG4gICAgICAgIGNvbnN0IHZpZXdwb3J0RWwgPSBnZXRWaWV3cG9ydEVsKHNjb3BlKTtcbiAgICAgICAgaWYgKCF2aWV3cG9ydEVsKSByZXR1cm47XG4gICAgICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IHdpbi5JbnRlcnNlY3Rpb25PYnNlcnZlcigoZW50cmllcykgPT4ge1xuICAgICAgICAgIGVudHJpZXMuZm9yRWFjaCgoZW50cnkpID0+IHtcbiAgICAgICAgICAgIGlmIChlbnRyeS5pbnRlcnNlY3Rpb25SYXRpbyA+IDApIHtcbiAgICAgICAgICAgICAgc2VuZCh7IHR5cGU6IFwidGh1bWIubWVhc3VyZVwiIH0pO1xuICAgICAgICAgICAgICBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBvYnNlcnZlci5vYnNlcnZlKHZpZXdwb3J0RWwpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICB0cmFja1doZWVsRXZlbnQoeyBzY29wZSB9KSB7XG4gICAgICAgIGNvbnN0IHNjcm9sbGJhcllFbCA9IGdldFNjcm9sbGJhcllFbChzY29wZSk7XG4gICAgICAgIGNvbnN0IHNjcm9sbGJhclhFbCA9IGdldFNjcm9sbGJhclhFbChzY29wZSk7XG4gICAgICAgIGlmICghc2Nyb2xsYmFyWUVsICYmICFzY3JvbGxiYXJYRWwpIHJldHVybjtcbiAgICAgICAgY29uc3Qgb25XaGVlbCA9IChldmVudCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHZpZXdwb3J0RWwgPSBnZXRWaWV3cG9ydEVsKHNjb3BlKTtcbiAgICAgICAgICBpZiAoIXZpZXdwb3J0RWwgfHwgZXZlbnQuY3RybEtleSkgcmV0dXJuO1xuICAgICAgICAgIGNvbnN0IG9yaWVudGF0aW9uID0gZXZlbnQuY3VycmVudFRhcmdldC5kYXRhc2V0Lm9yaWVudGF0aW9uO1xuICAgICAgICAgIGlmIChvcmllbnRhdGlvbiA9PT0gXCJ2ZXJ0aWNhbFwiKSB7XG4gICAgICAgICAgICBjb25zdCBjYW5TY3JvbGxZID0gdmlld3BvcnRFbC5zY3JvbGxIZWlnaHQgPiB2aWV3cG9ydEVsLmNsaWVudEhlaWdodDtcbiAgICAgICAgICAgIGNvbnN0IGF0VG9wID0gdmlld3BvcnRFbC5zY3JvbGxUb3AgPT09IDAgJiYgZXZlbnQuZGVsdGFZIDwgMDtcbiAgICAgICAgICAgIGNvbnN0IGF0Qm90dG9tID0gdmlld3BvcnRFbC5zY3JvbGxUb3AgPT09IHZpZXdwb3J0RWwuc2Nyb2xsSGVpZ2h0IC0gdmlld3BvcnRFbC5jbGllbnRIZWlnaHQgJiYgZXZlbnQuZGVsdGFZID4gMDtcbiAgICAgICAgICAgIGNvbnN0IHNob3VsZFNjcm9sbCA9IGNhblNjcm9sbFkgJiYgZXZlbnQuZGVsdGFZICE9PSAwICYmICEoYXRUb3AgfHwgYXRCb3R0b20pO1xuICAgICAgICAgICAgaWYgKCFzaG91bGRTY3JvbGwpIHJldHVybjtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB2aWV3cG9ydEVsLnNjcm9sbFRvcCArPSBldmVudC5kZWx0YVk7XG4gICAgICAgICAgfSBlbHNlIGlmIChvcmllbnRhdGlvbiA9PT0gXCJob3Jpem9udGFsXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhblNjcm9sbFggPSB2aWV3cG9ydEVsLnNjcm9sbFdpZHRoID4gdmlld3BvcnRFbC5jbGllbnRXaWR0aDtcbiAgICAgICAgICAgIGNvbnN0IGF0TGVmdCA9IHZpZXdwb3J0RWwuc2Nyb2xsTGVmdCA9PT0gMCAmJiBldmVudC5kZWx0YVggPCAwO1xuICAgICAgICAgICAgY29uc3QgYXRSaWdodCA9IHZpZXdwb3J0RWwuc2Nyb2xsTGVmdCA9PT0gdmlld3BvcnRFbC5zY3JvbGxXaWR0aCAtIHZpZXdwb3J0RWwuY2xpZW50V2lkdGggJiYgZXZlbnQuZGVsdGFYID4gMDtcbiAgICAgICAgICAgIGNvbnN0IHNob3VsZFNjcm9sbCA9IGNhblNjcm9sbFggJiYgZXZlbnQuZGVsdGFYICE9PSAwICYmICEoYXRMZWZ0IHx8IGF0UmlnaHQpO1xuICAgICAgICAgICAgaWYgKCFzaG91bGRTY3JvbGwpIHJldHVybjtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB2aWV3cG9ydEVsLnNjcm9sbExlZnQgKz0gZXZlbnQuZGVsdGFYO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGNhbGxBbGwoXG4gICAgICAgICAgc2Nyb2xsYmFyWUVsICYmIGFkZERvbUV2ZW50KHNjcm9sbGJhcllFbCwgXCJ3aGVlbFwiLCBvbldoZWVsLCB7IHBhc3NpdmU6IGZhbHNlIH0pLFxuICAgICAgICAgIHNjcm9sbGJhclhFbCAmJiBhZGREb21FdmVudChzY3JvbGxiYXJYRWwsIFwid2hlZWxcIiwgb25XaGVlbCwgeyBwYXNzaXZlOiBmYWxzZSB9KVxuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIHRyYWNrUG9pbnRlck1vdmUoeyBzY29wZSwgc2VuZCwgcmVmcyB9KSB7XG4gICAgICAgIGNvbnN0IGRvYyA9IHNjb3BlLmdldERvYygpO1xuICAgICAgICBjb25zdCBvcmllbnRhdGlvbiA9IHJlZnMuZ2V0KFwib3JpZW50YXRpb25cIik7XG4gICAgICAgIHJldHVybiB0cmFja1BvaW50ZXJNb3ZlKGRvYywge1xuICAgICAgICAgIG9uUG9pbnRlck1vdmUoeyBwb2ludCB9KSB7XG4gICAgICAgICAgICBzZW5kKHsgdHlwZTogXCJ0aHVtYi5wb2ludGVybW92ZVwiLCBvcmllbnRhdGlvbiwgcG9pbnQgfSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvblBvaW50ZXJVcCgpIHtcbiAgICAgICAgICAgIHNlbmQoeyB0eXBlOiBcInRodW1iLnBvaW50ZXJ1cFwiLCBvcmllbnRhdGlvbiB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufSk7XG52YXIgcHJvcHMgPSBjcmVhdGVQcm9wcygpKFtcImRpclwiLCBcImdldFJvb3ROb2RlXCIsIFwiaWRzXCIsIFwiaWRcIl0pO1xudmFyIHNwbGl0UHJvcHMgPSBjcmVhdGVTcGxpdFByb3BzKHByb3BzKTtcblxuZXhwb3J0IHsgYW5hdG9teSwgY29ubmVjdCwgbWFjaGluZSwgcHJvcHMsIHNwbGl0UHJvcHMgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@zag-js+scroll-area@1.21.7/node_modules/@zag-js/scroll-area/dist/index.mjs\n");

/***/ })

};
;