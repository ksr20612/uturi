"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@zag-js+focus-trap@1.21.7";
exports.ids = ["vendor-chunks/@zag-js+focus-trap@1.21.7"];
exports.modules = {

/***/ "(ssr)/../../node_modules/.pnpm/@zag-js+focus-trap@1.21.7/node_modules/@zag-js/focus-trap/dist/index.mjs":
/*!*********************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@zag-js+focus-trap@1.21.7/node_modules/@zag-js/focus-trap/dist/index.mjs ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FocusTrap: () => (/* binding */ FocusTrap),\n/* harmony export */   trapFocus: () => (/* binding */ trapFocus)\n/* harmony export */ });\n/* harmony import */ var _zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @zag-js/dom-query */ \"(ssr)/../../node_modules/.pnpm/@zag-js+dom-query@1.21.7/node_modules/@zag-js/dom-query/dist/index.mjs\");\n\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nvar activeFocusTraps = {\n  activateTrap(trapStack, trap) {\n    if (trapStack.length > 0) {\n      const activeTrap = trapStack[trapStack.length - 1];\n      if (activeTrap !== trap) {\n        activeTrap.pause();\n      }\n    }\n    const trapIndex = trapStack.indexOf(trap);\n    if (trapIndex === -1) {\n      trapStack.push(trap);\n    } else {\n      trapStack.splice(trapIndex, 1);\n      trapStack.push(trap);\n    }\n  },\n  deactivateTrap(trapStack, trap) {\n    const trapIndex = trapStack.indexOf(trap);\n    if (trapIndex !== -1) {\n      trapStack.splice(trapIndex, 1);\n    }\n    if (trapStack.length > 0) {\n      trapStack[trapStack.length - 1].unpause();\n    }\n  }\n};\nvar sharedTrapStack = [];\nvar FocusTrap = class {\n  constructor(elements, options) {\n    __publicField(this, \"trapStack\");\n    __publicField(this, \"config\");\n    __publicField(this, \"doc\");\n    __publicField(this, \"state\", {\n      containers: [],\n      containerGroups: [],\n      tabbableGroups: [],\n      nodeFocusedBeforeActivation: null,\n      mostRecentlyFocusedNode: null,\n      active: false,\n      paused: false,\n      delayInitialFocusTimer: void 0,\n      recentNavEvent: void 0\n    });\n    __publicField(this, \"listenerCleanups\", []);\n    __publicField(this, \"handleFocus\", (event) => {\n      const target = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.getEventTarget)(event);\n      const targetContained = this.findContainerIndex(target, event) >= 0;\n      if (targetContained || (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.isDocument)(target)) {\n        if (targetContained) {\n          this.state.mostRecentlyFocusedNode = target;\n        }\n      } else {\n        event.stopImmediatePropagation();\n        let nextNode;\n        let navAcrossContainers = true;\n        if (this.state.mostRecentlyFocusedNode) {\n          if ((0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.getTabIndex)(this.state.mostRecentlyFocusedNode) > 0) {\n            const mruContainerIdx = this.findContainerIndex(this.state.mostRecentlyFocusedNode);\n            const { tabbableNodes } = this.state.containerGroups[mruContainerIdx];\n            if (tabbableNodes.length > 0) {\n              const mruTabIdx = tabbableNodes.findIndex((node) => node === this.state.mostRecentlyFocusedNode);\n              if (mruTabIdx >= 0) {\n                if (this.config.isKeyForward(this.state.recentNavEvent)) {\n                  if (mruTabIdx + 1 < tabbableNodes.length) {\n                    nextNode = tabbableNodes[mruTabIdx + 1];\n                    navAcrossContainers = false;\n                  }\n                } else {\n                  if (mruTabIdx - 1 >= 0) {\n                    nextNode = tabbableNodes[mruTabIdx - 1];\n                    navAcrossContainers = false;\n                  }\n                }\n              }\n            }\n          } else {\n            if (!this.state.containerGroups.some((g) => g.tabbableNodes.some((n) => (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.getTabIndex)(n) > 0))) {\n              navAcrossContainers = false;\n            }\n          }\n        } else {\n          navAcrossContainers = false;\n        }\n        if (navAcrossContainers) {\n          nextNode = this.findNextNavNode({\n            // move FROM the MRU node, not event-related node (which will be the node that is\n            //  outside the trap causing the focus escape we're trying to fix)\n            target: this.state.mostRecentlyFocusedNode,\n            isBackward: this.config.isKeyBackward(this.state.recentNavEvent)\n          });\n        }\n        if (nextNode) {\n          this.tryFocus(nextNode);\n        } else {\n          this.tryFocus(this.state.mostRecentlyFocusedNode || this.getInitialFocusNode());\n        }\n      }\n      this.state.recentNavEvent = void 0;\n    });\n    __publicField(this, \"handlePointerDown\", (event) => {\n      const target = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.getEventTarget)(event);\n      if (this.findContainerIndex(target, event) >= 0) {\n        return;\n      }\n      if (valueOrHandler(this.config.clickOutsideDeactivates, event)) {\n        this.deactivate({ returnFocus: this.config.returnFocusOnDeactivate });\n        return;\n      }\n      if (valueOrHandler(this.config.allowOutsideClick, event)) {\n        return;\n      }\n      event.preventDefault();\n    });\n    __publicField(this, \"handleClick\", (event) => {\n      const target = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.getEventTarget)(event);\n      if (this.findContainerIndex(target, event) >= 0) {\n        return;\n      }\n      if (valueOrHandler(this.config.clickOutsideDeactivates, event)) {\n        return;\n      }\n      if (valueOrHandler(this.config.allowOutsideClick, event)) {\n        return;\n      }\n      event.preventDefault();\n      event.stopImmediatePropagation();\n    });\n    __publicField(this, \"handleTabKey\", (event) => {\n      if (this.config.isKeyForward(event) || this.config.isKeyBackward(event)) {\n        this.state.recentNavEvent = event;\n        const isBackward = this.config.isKeyBackward(event);\n        const destinationNode = this.findNextNavNode({ event, isBackward });\n        if (!destinationNode) return;\n        if (isTabEvent(event)) {\n          event.preventDefault();\n        }\n        this.tryFocus(destinationNode);\n      }\n    });\n    __publicField(this, \"handleEscapeKey\", (event) => {\n      if (isEscapeEvent(event) && valueOrHandler(this.config.escapeDeactivates, event) !== false) {\n        event.preventDefault();\n        this.deactivate();\n      }\n    });\n    __publicField(this, \"_mutationObserver\");\n    __publicField(this, \"setupMutationObserver\", () => {\n      const win = this.doc.defaultView || window;\n      this._mutationObserver = new win.MutationObserver((mutations) => {\n        const isFocusedNodeRemoved = mutations.some((mutation) => {\n          const removedNodes = Array.from(mutation.removedNodes);\n          return removedNodes.some((node) => node === this.state.mostRecentlyFocusedNode);\n        });\n        if (isFocusedNodeRemoved) {\n          this.tryFocus(this.getInitialFocusNode());\n        }\n      });\n    });\n    __publicField(this, \"updateObservedNodes\", () => {\n      this._mutationObserver?.disconnect();\n      if (this.state.active && !this.state.paused) {\n        this.state.containers.map((container) => {\n          this._mutationObserver?.observe(container, { subtree: true, childList: true });\n        });\n      }\n    });\n    __publicField(this, \"getInitialFocusNode\", () => {\n      let node = this.getNodeForOption(\"initialFocus\", { hasFallback: true });\n      if (node === false) {\n        return false;\n      }\n      if (node === void 0 || node && !(0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.isFocusable)(node)) {\n        if (this.findContainerIndex(this.doc.activeElement) >= 0) {\n          node = this.doc.activeElement;\n        } else {\n          const firstTabbableGroup = this.state.tabbableGroups[0];\n          const firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;\n          node = firstTabbableNode || this.getNodeForOption(\"fallbackFocus\");\n        }\n      } else if (node === null) {\n        node = this.getNodeForOption(\"fallbackFocus\");\n      }\n      if (!node) {\n        throw new Error(\"Your focus-trap needs to have at least one focusable element\");\n      }\n      if (!node.isConnected) {\n        node = this.getNodeForOption(\"fallbackFocus\");\n      }\n      return node;\n    });\n    __publicField(this, \"tryFocus\", (node) => {\n      if (node === false) return;\n      if (node === (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.getActiveElement)(this.doc)) return;\n      if (!node || !node.focus) {\n        this.tryFocus(this.getInitialFocusNode());\n        return;\n      }\n      node.focus({ preventScroll: !!this.config.preventScroll });\n      this.state.mostRecentlyFocusedNode = node;\n      if (isSelectableInput(node)) {\n        node.select();\n      }\n    });\n    __publicField(this, \"deactivate\", (deactivateOptions) => {\n      if (!this.state.active) return this;\n      const options = {\n        onDeactivate: this.config.onDeactivate,\n        onPostDeactivate: this.config.onPostDeactivate,\n        checkCanReturnFocus: this.config.checkCanReturnFocus,\n        ...deactivateOptions\n      };\n      clearTimeout(this.state.delayInitialFocusTimer);\n      this.state.delayInitialFocusTimer = void 0;\n      this.removeListeners();\n      this.state.active = false;\n      this.state.paused = false;\n      this.updateObservedNodes();\n      activeFocusTraps.deactivateTrap(this.trapStack, this);\n      const onDeactivate = this.getOption(options, \"onDeactivate\");\n      const onPostDeactivate = this.getOption(options, \"onPostDeactivate\");\n      const checkCanReturnFocus = this.getOption(options, \"checkCanReturnFocus\");\n      const returnFocus = this.getOption(options, \"returnFocus\", \"returnFocusOnDeactivate\");\n      onDeactivate?.();\n      const finishDeactivation = () => {\n        delay(() => {\n          if (returnFocus) {\n            const returnFocusNode = this.getReturnFocusNode(this.state.nodeFocusedBeforeActivation);\n            this.tryFocus(returnFocusNode);\n          }\n          onPostDeactivate?.();\n        });\n      };\n      if (returnFocus && checkCanReturnFocus) {\n        const returnFocusNode = this.getReturnFocusNode(this.state.nodeFocusedBeforeActivation);\n        checkCanReturnFocus(returnFocusNode).then(finishDeactivation, finishDeactivation);\n        return this;\n      }\n      finishDeactivation();\n      return this;\n    });\n    __publicField(this, \"pause\", (pauseOptions) => {\n      if (this.state.paused || !this.state.active) {\n        return this;\n      }\n      const onPause = this.getOption(pauseOptions, \"onPause\");\n      const onPostPause = this.getOption(pauseOptions, \"onPostPause\");\n      this.state.paused = true;\n      onPause?.();\n      this.removeListeners();\n      this.updateObservedNodes();\n      onPostPause?.();\n      return this;\n    });\n    __publicField(this, \"unpause\", (unpauseOptions) => {\n      if (!this.state.paused || !this.state.active) {\n        return this;\n      }\n      const onUnpause = this.getOption(unpauseOptions, \"onUnpause\");\n      const onPostUnpause = this.getOption(unpauseOptions, \"onPostUnpause\");\n      this.state.paused = false;\n      onUnpause?.();\n      this.updateTabbableNodes();\n      this.addListeners();\n      this.updateObservedNodes();\n      onPostUnpause?.();\n      return this;\n    });\n    __publicField(this, \"updateContainerElements\", (containerElements) => {\n      this.state.containers = Array.isArray(containerElements) ? containerElements.filter(Boolean) : [containerElements].filter(Boolean);\n      if (this.state.active) {\n        this.updateTabbableNodes();\n      }\n      this.updateObservedNodes();\n      return this;\n    });\n    __publicField(this, \"getReturnFocusNode\", (previousActiveElement) => {\n      const node = this.getNodeForOption(\"setReturnFocus\", {\n        params: [previousActiveElement]\n      });\n      return node ? node : node === false ? false : previousActiveElement;\n    });\n    __publicField(this, \"getOption\", (configOverrideOptions, optionName, configOptionName) => {\n      return configOverrideOptions && configOverrideOptions[optionName] !== void 0 ? configOverrideOptions[optionName] : (\n        // @ts-expect-error\n        this.config[configOptionName || optionName]\n      );\n    });\n    __publicField(this, \"getNodeForOption\", (optionName, { hasFallback = false, params = [] } = {}) => {\n      let optionValue = this.config[optionName];\n      if (typeof optionValue === \"function\") optionValue = optionValue(...params);\n      if (optionValue === true) optionValue = void 0;\n      if (!optionValue) {\n        if (optionValue === void 0 || optionValue === false) {\n          return optionValue;\n        }\n        throw new Error(`\\`${optionName}\\` was specified but was not a node, or did not return a node`);\n      }\n      let node = optionValue;\n      if (typeof optionValue === \"string\") {\n        try {\n          node = this.doc.querySelector(optionValue);\n        } catch (err) {\n          throw new Error(`\\`${optionName}\\` appears to be an invalid selector; error=\"${err.message}\"`);\n        }\n        if (!node) {\n          if (!hasFallback) {\n            throw new Error(`\\`${optionName}\\` as selector refers to no known node`);\n          }\n        }\n      }\n      return node;\n    });\n    __publicField(this, \"findNextNavNode\", (opts) => {\n      const { event, isBackward = false } = opts;\n      const target = opts.target || (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.getEventTarget)(event);\n      this.updateTabbableNodes();\n      let destinationNode = null;\n      if (this.state.tabbableGroups.length > 0) {\n        const containerIndex = this.findContainerIndex(target, event);\n        const containerGroup = containerIndex >= 0 ? this.state.containerGroups[containerIndex] : void 0;\n        if (containerIndex < 0) {\n          if (isBackward) {\n            destinationNode = this.state.tabbableGroups[this.state.tabbableGroups.length - 1].lastTabbableNode;\n          } else {\n            destinationNode = this.state.tabbableGroups[0].firstTabbableNode;\n          }\n        } else if (isBackward) {\n          let startOfGroupIndex = this.state.tabbableGroups.findIndex(\n            ({ firstTabbableNode }) => target === firstTabbableNode\n          );\n          if (startOfGroupIndex < 0 && (containerGroup?.container === target || (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.isFocusable)(target) && !(0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.isTabbable)(target) && !containerGroup?.nextTabbableNode(target, false))) {\n            startOfGroupIndex = containerIndex;\n          }\n          if (startOfGroupIndex >= 0) {\n            const destinationGroupIndex = startOfGroupIndex === 0 ? this.state.tabbableGroups.length - 1 : startOfGroupIndex - 1;\n            const destinationGroup = this.state.tabbableGroups[destinationGroupIndex];\n            destinationNode = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.getTabIndex)(target) >= 0 ? destinationGroup.lastTabbableNode : destinationGroup.lastDomTabbableNode;\n          } else if (!isTabEvent(event)) {\n            destinationNode = containerGroup?.nextTabbableNode(target, false);\n          }\n        } else {\n          let lastOfGroupIndex = this.state.tabbableGroups.findIndex(\n            ({ lastTabbableNode }) => target === lastTabbableNode\n          );\n          if (lastOfGroupIndex < 0 && (containerGroup?.container === target || (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.isFocusable)(target) && !(0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.isTabbable)(target) && !containerGroup?.nextTabbableNode(target))) {\n            lastOfGroupIndex = containerIndex;\n          }\n          if (lastOfGroupIndex >= 0) {\n            const destinationGroupIndex = lastOfGroupIndex === this.state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;\n            const destinationGroup = this.state.tabbableGroups[destinationGroupIndex];\n            destinationNode = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.getTabIndex)(target) >= 0 ? destinationGroup.firstTabbableNode : destinationGroup.firstDomTabbableNode;\n          } else if (!isTabEvent(event)) {\n            destinationNode = containerGroup?.nextTabbableNode(target);\n          }\n        }\n      } else {\n        destinationNode = this.getNodeForOption(\"fallbackFocus\");\n      }\n      return destinationNode;\n    });\n    this.trapStack = options.trapStack || sharedTrapStack;\n    const config = {\n      returnFocusOnDeactivate: true,\n      escapeDeactivates: true,\n      delayInitialFocus: true,\n      isKeyForward(e) {\n        return isTabEvent(e) && !e.shiftKey;\n      },\n      isKeyBackward(e) {\n        return isTabEvent(e) && e.shiftKey;\n      },\n      ...options\n    };\n    this.doc = config.document || (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.getDocument)(Array.isArray(elements) ? elements[0] : elements);\n    this.config = config;\n    this.updateContainerElements(elements);\n    this.setupMutationObserver();\n  }\n  get active() {\n    return this.state.active;\n  }\n  get paused() {\n    return this.state.paused;\n  }\n  findContainerIndex(element, event) {\n    const composedPath = typeof event?.composedPath === \"function\" ? event.composedPath() : void 0;\n    return this.state.containerGroups.findIndex(\n      ({ container, tabbableNodes }) => container.contains(element) || composedPath?.includes(container) || tabbableNodes.find((node) => node === element)\n    );\n  }\n  updateTabbableNodes() {\n    this.state.containerGroups = this.state.containers.map((container) => {\n      const tabbableNodes = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.getTabbables)(container);\n      const focusableNodes = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.getFocusables)(container);\n      const firstTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[0] : void 0;\n      const lastTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : void 0;\n      const firstDomTabbableNode = focusableNodes.find((node) => (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.isTabbable)(node));\n      const lastDomTabbableNode = focusableNodes.slice().reverse().find((node) => (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.isTabbable)(node));\n      const posTabIndexesFound = !!tabbableNodes.find((node) => (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.getTabIndex)(node) > 0);\n      function nextTabbableNode(node, forward = true) {\n        const nodeIdx = tabbableNodes.indexOf(node);\n        if (nodeIdx < 0) {\n          if (forward) {\n            return focusableNodes.slice(focusableNodes.indexOf(node) + 1).find((el) => (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.isTabbable)(el));\n          }\n          return focusableNodes.slice(0, focusableNodes.indexOf(node)).reverse().find((el) => (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.isTabbable)(el));\n        }\n        return tabbableNodes[nodeIdx + (forward ? 1 : -1)];\n      }\n      return {\n        container,\n        tabbableNodes,\n        focusableNodes,\n        posTabIndexesFound,\n        firstTabbableNode,\n        lastTabbableNode,\n        firstDomTabbableNode,\n        lastDomTabbableNode,\n        nextTabbableNode\n      };\n    });\n    this.state.tabbableGroups = this.state.containerGroups.filter((group) => group.tabbableNodes.length > 0);\n    if (this.state.tabbableGroups.length <= 0 && !this.getNodeForOption(\"fallbackFocus\")) {\n      throw new Error(\n        \"Your focus-trap must have at least one container with at least one tabbable node in it at all times\"\n      );\n    }\n    if (this.state.containerGroups.find((g) => g.posTabIndexesFound) && this.state.containerGroups.length > 1) {\n      throw new Error(\n        \"At least one node with a positive tabindex was found in one of your focus-trap's multiple containers. Positive tabindexes are only supported in single-container focus-traps.\"\n      );\n    }\n  }\n  addListeners() {\n    if (!this.state.active) return;\n    activeFocusTraps.activateTrap(this.trapStack, this);\n    this.state.delayInitialFocusTimer = this.config.delayInitialFocus ? delay(() => {\n      this.tryFocus(this.getInitialFocusNode());\n    }) : this.tryFocus(this.getInitialFocusNode());\n    this.listenerCleanups.push(\n      (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.addDomEvent)(this.doc, \"focusin\", this.handleFocus, true),\n      (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.addDomEvent)(this.doc, \"mousedown\", this.handlePointerDown, { capture: true, passive: false }),\n      (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.addDomEvent)(this.doc, \"touchstart\", this.handlePointerDown, { capture: true, passive: false }),\n      (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.addDomEvent)(this.doc, \"click\", this.handleClick, { capture: true, passive: false }),\n      (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.addDomEvent)(this.doc, \"keydown\", this.handleTabKey, { capture: true, passive: false }),\n      (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.addDomEvent)(this.doc, \"keydown\", this.handleEscapeKey)\n    );\n    return this;\n  }\n  removeListeners() {\n    if (!this.state.active) return;\n    this.listenerCleanups.forEach((cleanup) => cleanup());\n    this.listenerCleanups = [];\n    return this;\n  }\n  activate(activateOptions) {\n    if (this.state.active) {\n      return this;\n    }\n    const onActivate = this.getOption(activateOptions, \"onActivate\");\n    const onPostActivate = this.getOption(activateOptions, \"onPostActivate\");\n    const checkCanFocusTrap = this.getOption(activateOptions, \"checkCanFocusTrap\");\n    if (!checkCanFocusTrap) {\n      this.updateTabbableNodes();\n    }\n    this.state.active = true;\n    this.state.paused = false;\n    this.state.nodeFocusedBeforeActivation = this.doc.activeElement || null;\n    onActivate?.();\n    const finishActivation = () => {\n      if (checkCanFocusTrap) {\n        this.updateTabbableNodes();\n      }\n      this.addListeners();\n      this.updateObservedNodes();\n      onPostActivate?.();\n    };\n    if (checkCanFocusTrap) {\n      checkCanFocusTrap(this.state.containers.concat()).then(finishActivation, finishActivation);\n      return this;\n    }\n    finishActivation();\n    return this;\n  }\n};\nvar isTabEvent = (event) => event.key === \"Tab\";\nvar valueOrHandler = (value, ...params) => typeof value === \"function\" ? value(...params) : value;\nvar isEscapeEvent = (event) => !event.isComposing && event.key === \"Escape\";\nvar delay = (fn) => setTimeout(fn, 0);\nvar isSelectableInput = (node) => node.localName === \"input\" && \"select\" in node && typeof node.select === \"function\";\n\n// src/index.ts\nfunction trapFocus(el, options = {}) {\n  let trap;\n  const cleanup = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.raf)(() => {\n    const contentEl = typeof el === \"function\" ? el() : el;\n    if (!contentEl) return;\n    trap = new FocusTrap(contentEl, {\n      escapeDeactivates: false,\n      allowOutsideClick: true,\n      preventScroll: true,\n      returnFocusOnDeactivate: true,\n      delayInitialFocus: false,\n      fallbackFocus: contentEl,\n      ...options,\n      document: (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.getDocument)(contentEl)\n    });\n    try {\n      trap.activate();\n    } catch {\n    }\n  });\n  return function destroy() {\n    trap?.deactivate();\n    cleanup();\n  };\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0B6YWctanMrZm9jdXMtdHJhcEAxLjIxLjcvbm9kZV9tb2R1bGVzL0B6YWctanMvZm9jdXMtdHJhcC9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBbUw7O0FBRW5MO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHFCQUFxQixpRUFBYztBQUNuQztBQUNBLDZCQUE2Qiw2REFBVTtBQUN2QztBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDhEQUFXO0FBQ3pCO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLG9GQUFvRiw4REFBVztBQUMvRjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxxQkFBcUIsaUVBQWM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsa0RBQWtEO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtB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QUNBO0FBQ0E7QUFDQSxnQkFBZ0IsOERBQVc7QUFDM0IsS0FBSztBQUNMO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AdXR1cmkvdXR1cmkvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0B6YWctanMrZm9jdXMtdHJhcEAxLjIxLjcvbm9kZV9tb2R1bGVzL0B6YWctanMvZm9jdXMtdHJhcC9kaXN0L2luZGV4Lm1qcz82YjRmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldERvY3VtZW50LCBnZXRUYWJiYWJsZXMsIGdldEZvY3VzYWJsZXMsIGlzVGFiYmFibGUsIGdldFRhYkluZGV4LCBhZGREb21FdmVudCwgcmFmLCBnZXRFdmVudFRhcmdldCwgaXNEb2N1bWVudCwgaXNGb2N1c2FibGUsIGdldEFjdGl2ZUVsZW1lbnQgfSBmcm9tICdAemFnLWpzL2RvbS1xdWVyeSc7XG5cbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19wdWJsaWNGaWVsZCA9IChvYmosIGtleSwgdmFsdWUpID0+IF9fZGVmTm9ybWFsUHJvcChvYmosIHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG52YXIgYWN0aXZlRm9jdXNUcmFwcyA9IHtcbiAgYWN0aXZhdGVUcmFwKHRyYXBTdGFjaywgdHJhcCkge1xuICAgIGlmICh0cmFwU3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgYWN0aXZlVHJhcCA9IHRyYXBTdGFja1t0cmFwU3RhY2subGVuZ3RoIC0gMV07XG4gICAgICBpZiAoYWN0aXZlVHJhcCAhPT0gdHJhcCkge1xuICAgICAgICBhY3RpdmVUcmFwLnBhdXNlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHRyYXBJbmRleCA9IHRyYXBTdGFjay5pbmRleE9mKHRyYXApO1xuICAgIGlmICh0cmFwSW5kZXggPT09IC0xKSB7XG4gICAgICB0cmFwU3RhY2sucHVzaCh0cmFwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJhcFN0YWNrLnNwbGljZSh0cmFwSW5kZXgsIDEpO1xuICAgICAgdHJhcFN0YWNrLnB1c2godHJhcCk7XG4gICAgfVxuICB9LFxuICBkZWFjdGl2YXRlVHJhcCh0cmFwU3RhY2ssIHRyYXApIHtcbiAgICBjb25zdCB0cmFwSW5kZXggPSB0cmFwU3RhY2suaW5kZXhPZih0cmFwKTtcbiAgICBpZiAodHJhcEluZGV4ICE9PSAtMSkge1xuICAgICAgdHJhcFN0YWNrLnNwbGljZSh0cmFwSW5kZXgsIDEpO1xuICAgIH1cbiAgICBpZiAodHJhcFN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgIHRyYXBTdGFja1t0cmFwU3RhY2subGVuZ3RoIC0gMV0udW5wYXVzZSgpO1xuICAgIH1cbiAgfVxufTtcbnZhciBzaGFyZWRUcmFwU3RhY2sgPSBbXTtcbnZhciBGb2N1c1RyYXAgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGVsZW1lbnRzLCBvcHRpb25zKSB7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInRyYXBTdGFja1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiY29uZmlnXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJkb2NcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInN0YXRlXCIsIHtcbiAgICAgIGNvbnRhaW5lcnM6IFtdLFxuICAgICAgY29udGFpbmVyR3JvdXBzOiBbXSxcbiAgICAgIHRhYmJhYmxlR3JvdXBzOiBbXSxcbiAgICAgIG5vZGVGb2N1c2VkQmVmb3JlQWN0aXZhdGlvbjogbnVsbCxcbiAgICAgIG1vc3RSZWNlbnRseUZvY3VzZWROb2RlOiBudWxsLFxuICAgICAgYWN0aXZlOiBmYWxzZSxcbiAgICAgIHBhdXNlZDogZmFsc2UsXG4gICAgICBkZWxheUluaXRpYWxGb2N1c1RpbWVyOiB2b2lkIDAsXG4gICAgICByZWNlbnROYXZFdmVudDogdm9pZCAwXG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImxpc3RlbmVyQ2xlYW51cHNcIiwgW10pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJoYW5kbGVGb2N1c1wiLCAoZXZlbnQpID0+IHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IGdldEV2ZW50VGFyZ2V0KGV2ZW50KTtcbiAgICAgIGNvbnN0IHRhcmdldENvbnRhaW5lZCA9IHRoaXMuZmluZENvbnRhaW5lckluZGV4KHRhcmdldCwgZXZlbnQpID49IDA7XG4gICAgICBpZiAodGFyZ2V0Q29udGFpbmVkIHx8IGlzRG9jdW1lbnQodGFyZ2V0KSkge1xuICAgICAgICBpZiAodGFyZ2V0Q29udGFpbmVkKSB7XG4gICAgICAgICAgdGhpcy5zdGF0ZS5tb3N0UmVjZW50bHlGb2N1c2VkTm9kZSA9IHRhcmdldDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGxldCBuZXh0Tm9kZTtcbiAgICAgICAgbGV0IG5hdkFjcm9zc0NvbnRhaW5lcnMgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5tb3N0UmVjZW50bHlGb2N1c2VkTm9kZSkge1xuICAgICAgICAgIGlmIChnZXRUYWJJbmRleCh0aGlzLnN0YXRlLm1vc3RSZWNlbnRseUZvY3VzZWROb2RlKSA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IG1ydUNvbnRhaW5lcklkeCA9IHRoaXMuZmluZENvbnRhaW5lckluZGV4KHRoaXMuc3RhdGUubW9zdFJlY2VudGx5Rm9jdXNlZE5vZGUpO1xuICAgICAgICAgICAgY29uc3QgeyB0YWJiYWJsZU5vZGVzIH0gPSB0aGlzLnN0YXRlLmNvbnRhaW5lckdyb3Vwc1ttcnVDb250YWluZXJJZHhdO1xuICAgICAgICAgICAgaWYgKHRhYmJhYmxlTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBjb25zdCBtcnVUYWJJZHggPSB0YWJiYWJsZU5vZGVzLmZpbmRJbmRleCgobm9kZSkgPT4gbm9kZSA9PT0gdGhpcy5zdGF0ZS5tb3N0UmVjZW50bHlGb2N1c2VkTm9kZSk7XG4gICAgICAgICAgICAgIGlmIChtcnVUYWJJZHggPj0gMCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZy5pc0tleUZvcndhcmQodGhpcy5zdGF0ZS5yZWNlbnROYXZFdmVudCkpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChtcnVUYWJJZHggKyAxIDwgdGFiYmFibGVOb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSB0YWJiYWJsZU5vZGVzW21ydVRhYklkeCArIDFdO1xuICAgICAgICAgICAgICAgICAgICBuYXZBY3Jvc3NDb250YWluZXJzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGlmIChtcnVUYWJJZHggLSAxID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSB0YWJiYWJsZU5vZGVzW21ydVRhYklkeCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBuYXZBY3Jvc3NDb250YWluZXJzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5zdGF0ZS5jb250YWluZXJHcm91cHMuc29tZSgoZykgPT4gZy50YWJiYWJsZU5vZGVzLnNvbWUoKG4pID0+IGdldFRhYkluZGV4KG4pID4gMCkpKSB7XG4gICAgICAgICAgICAgIG5hdkFjcm9zc0NvbnRhaW5lcnMgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmF2QWNyb3NzQ29udGFpbmVycyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYXZBY3Jvc3NDb250YWluZXJzKSB7XG4gICAgICAgICAgbmV4dE5vZGUgPSB0aGlzLmZpbmROZXh0TmF2Tm9kZSh7XG4gICAgICAgICAgICAvLyBtb3ZlIEZST00gdGhlIE1SVSBub2RlLCBub3QgZXZlbnQtcmVsYXRlZCBub2RlICh3aGljaCB3aWxsIGJlIHRoZSBub2RlIHRoYXQgaXNcbiAgICAgICAgICAgIC8vICBvdXRzaWRlIHRoZSB0cmFwIGNhdXNpbmcgdGhlIGZvY3VzIGVzY2FwZSB3ZSdyZSB0cnlpbmcgdG8gZml4KVxuICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLnN0YXRlLm1vc3RSZWNlbnRseUZvY3VzZWROb2RlLFxuICAgICAgICAgICAgaXNCYWNrd2FyZDogdGhpcy5jb25maWcuaXNLZXlCYWNrd2FyZCh0aGlzLnN0YXRlLnJlY2VudE5hdkV2ZW50KVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXh0Tm9kZSkge1xuICAgICAgICAgIHRoaXMudHJ5Rm9jdXMobmV4dE5vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMudHJ5Rm9jdXModGhpcy5zdGF0ZS5tb3N0UmVjZW50bHlGb2N1c2VkTm9kZSB8fCB0aGlzLmdldEluaXRpYWxGb2N1c05vZGUoKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuc3RhdGUucmVjZW50TmF2RXZlbnQgPSB2b2lkIDA7XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImhhbmRsZVBvaW50ZXJEb3duXCIsIChldmVudCkgPT4ge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gZ2V0RXZlbnRUYXJnZXQoZXZlbnQpO1xuICAgICAgaWYgKHRoaXMuZmluZENvbnRhaW5lckluZGV4KHRhcmdldCwgZXZlbnQpID49IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlT3JIYW5kbGVyKHRoaXMuY29uZmlnLmNsaWNrT3V0c2lkZURlYWN0aXZhdGVzLCBldmVudCkpIHtcbiAgICAgICAgdGhpcy5kZWFjdGl2YXRlKHsgcmV0dXJuRm9jdXM6IHRoaXMuY29uZmlnLnJldHVybkZvY3VzT25EZWFjdGl2YXRlIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodmFsdWVPckhhbmRsZXIodGhpcy5jb25maWcuYWxsb3dPdXRzaWRlQ2xpY2ssIGV2ZW50KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJoYW5kbGVDbGlja1wiLCAoZXZlbnQpID0+IHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IGdldEV2ZW50VGFyZ2V0KGV2ZW50KTtcbiAgICAgIGlmICh0aGlzLmZpbmRDb250YWluZXJJbmRleCh0YXJnZXQsIGV2ZW50KSA+PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZU9ySGFuZGxlcih0aGlzLmNvbmZpZy5jbGlja091dHNpZGVEZWFjdGl2YXRlcywgZXZlbnQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZU9ySGFuZGxlcih0aGlzLmNvbmZpZy5hbGxvd091dHNpZGVDbGljaywgZXZlbnQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiaGFuZGxlVGFiS2V5XCIsIChldmVudCkgPT4ge1xuICAgICAgaWYgKHRoaXMuY29uZmlnLmlzS2V5Rm9yd2FyZChldmVudCkgfHwgdGhpcy5jb25maWcuaXNLZXlCYWNrd2FyZChldmVudCkpIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5yZWNlbnROYXZFdmVudCA9IGV2ZW50O1xuICAgICAgICBjb25zdCBpc0JhY2t3YXJkID0gdGhpcy5jb25maWcuaXNLZXlCYWNrd2FyZChldmVudCk7XG4gICAgICAgIGNvbnN0IGRlc3RpbmF0aW9uTm9kZSA9IHRoaXMuZmluZE5leHROYXZOb2RlKHsgZXZlbnQsIGlzQmFja3dhcmQgfSk7XG4gICAgICAgIGlmICghZGVzdGluYXRpb25Ob2RlKSByZXR1cm47XG4gICAgICAgIGlmIChpc1RhYkV2ZW50KGV2ZW50KSkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cnlGb2N1cyhkZXN0aW5hdGlvbk5vZGUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJoYW5kbGVFc2NhcGVLZXlcIiwgKGV2ZW50KSA9PiB7XG4gICAgICBpZiAoaXNFc2NhcGVFdmVudChldmVudCkgJiYgdmFsdWVPckhhbmRsZXIodGhpcy5jb25maWcuZXNjYXBlRGVhY3RpdmF0ZXMsIGV2ZW50KSAhPT0gZmFsc2UpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5kZWFjdGl2YXRlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9tdXRhdGlvbk9ic2VydmVyXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzZXR1cE11dGF0aW9uT2JzZXJ2ZXJcIiwgKCkgPT4ge1xuICAgICAgY29uc3Qgd2luID0gdGhpcy5kb2MuZGVmYXVsdFZpZXcgfHwgd2luZG93O1xuICAgICAgdGhpcy5fbXV0YXRpb25PYnNlcnZlciA9IG5ldyB3aW4uTXV0YXRpb25PYnNlcnZlcigobXV0YXRpb25zKSA9PiB7XG4gICAgICAgIGNvbnN0IGlzRm9jdXNlZE5vZGVSZW1vdmVkID0gbXV0YXRpb25zLnNvbWUoKG11dGF0aW9uKSA9PiB7XG4gICAgICAgICAgY29uc3QgcmVtb3ZlZE5vZGVzID0gQXJyYXkuZnJvbShtdXRhdGlvbi5yZW1vdmVkTm9kZXMpO1xuICAgICAgICAgIHJldHVybiByZW1vdmVkTm9kZXMuc29tZSgobm9kZSkgPT4gbm9kZSA9PT0gdGhpcy5zdGF0ZS5tb3N0UmVjZW50bHlGb2N1c2VkTm9kZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaXNGb2N1c2VkTm9kZVJlbW92ZWQpIHtcbiAgICAgICAgICB0aGlzLnRyeUZvY3VzKHRoaXMuZ2V0SW5pdGlhbEZvY3VzTm9kZSgpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInVwZGF0ZU9ic2VydmVkTm9kZXNcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5fbXV0YXRpb25PYnNlcnZlcj8uZGlzY29ubmVjdCgpO1xuICAgICAgaWYgKHRoaXMuc3RhdGUuYWN0aXZlICYmICF0aGlzLnN0YXRlLnBhdXNlZCkge1xuICAgICAgICB0aGlzLnN0YXRlLmNvbnRhaW5lcnMubWFwKChjb250YWluZXIpID0+IHtcbiAgICAgICAgICB0aGlzLl9tdXRhdGlvbk9ic2VydmVyPy5vYnNlcnZlKGNvbnRhaW5lciwgeyBzdWJ0cmVlOiB0cnVlLCBjaGlsZExpc3Q6IHRydWUgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJnZXRJbml0aWFsRm9jdXNOb2RlXCIsICgpID0+IHtcbiAgICAgIGxldCBub2RlID0gdGhpcy5nZXROb2RlRm9yT3B0aW9uKFwiaW5pdGlhbEZvY3VzXCIsIHsgaGFzRmFsbGJhY2s6IHRydWUgfSk7XG4gICAgICBpZiAobm9kZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUgPT09IHZvaWQgMCB8fCBub2RlICYmICFpc0ZvY3VzYWJsZShub2RlKSkge1xuICAgICAgICBpZiAodGhpcy5maW5kQ29udGFpbmVySW5kZXgodGhpcy5kb2MuYWN0aXZlRWxlbWVudCkgPj0gMCkge1xuICAgICAgICAgIG5vZGUgPSB0aGlzLmRvYy5hY3RpdmVFbGVtZW50O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGZpcnN0VGFiYmFibGVHcm91cCA9IHRoaXMuc3RhdGUudGFiYmFibGVHcm91cHNbMF07XG4gICAgICAgICAgY29uc3QgZmlyc3RUYWJiYWJsZU5vZGUgPSBmaXJzdFRhYmJhYmxlR3JvdXAgJiYgZmlyc3RUYWJiYWJsZUdyb3VwLmZpcnN0VGFiYmFibGVOb2RlO1xuICAgICAgICAgIG5vZGUgPSBmaXJzdFRhYmJhYmxlTm9kZSB8fCB0aGlzLmdldE5vZGVGb3JPcHRpb24oXCJmYWxsYmFja0ZvY3VzXCIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgbm9kZSA9IHRoaXMuZ2V0Tm9kZUZvck9wdGlvbihcImZhbGxiYWNrRm9jdXNcIik7XG4gICAgICB9XG4gICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91ciBmb2N1cy10cmFwIG5lZWRzIHRvIGhhdmUgYXQgbGVhc3Qgb25lIGZvY3VzYWJsZSBlbGVtZW50XCIpO1xuICAgICAgfVxuICAgICAgaWYgKCFub2RlLmlzQ29ubmVjdGVkKSB7XG4gICAgICAgIG5vZGUgPSB0aGlzLmdldE5vZGVGb3JPcHRpb24oXCJmYWxsYmFja0ZvY3VzXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInRyeUZvY3VzXCIsIChub2RlKSA9PiB7XG4gICAgICBpZiAobm9kZSA9PT0gZmFsc2UpIHJldHVybjtcbiAgICAgIGlmIChub2RlID09PSBnZXRBY3RpdmVFbGVtZW50KHRoaXMuZG9jKSkgcmV0dXJuO1xuICAgICAgaWYgKCFub2RlIHx8ICFub2RlLmZvY3VzKSB7XG4gICAgICAgIHRoaXMudHJ5Rm9jdXModGhpcy5nZXRJbml0aWFsRm9jdXNOb2RlKCkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBub2RlLmZvY3VzKHsgcHJldmVudFNjcm9sbDogISF0aGlzLmNvbmZpZy5wcmV2ZW50U2Nyb2xsIH0pO1xuICAgICAgdGhpcy5zdGF0ZS5tb3N0UmVjZW50bHlGb2N1c2VkTm9kZSA9IG5vZGU7XG4gICAgICBpZiAoaXNTZWxlY3RhYmxlSW5wdXQobm9kZSkpIHtcbiAgICAgICAgbm9kZS5zZWxlY3QoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZGVhY3RpdmF0ZVwiLCAoZGVhY3RpdmF0ZU9wdGlvbnMpID0+IHtcbiAgICAgIGlmICghdGhpcy5zdGF0ZS5hY3RpdmUpIHJldHVybiB0aGlzO1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgb25EZWFjdGl2YXRlOiB0aGlzLmNvbmZpZy5vbkRlYWN0aXZhdGUsXG4gICAgICAgIG9uUG9zdERlYWN0aXZhdGU6IHRoaXMuY29uZmlnLm9uUG9zdERlYWN0aXZhdGUsXG4gICAgICAgIGNoZWNrQ2FuUmV0dXJuRm9jdXM6IHRoaXMuY29uZmlnLmNoZWNrQ2FuUmV0dXJuRm9jdXMsXG4gICAgICAgIC4uLmRlYWN0aXZhdGVPcHRpb25zXG4gICAgICB9O1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuc3RhdGUuZGVsYXlJbml0aWFsRm9jdXNUaW1lcik7XG4gICAgICB0aGlzLnN0YXRlLmRlbGF5SW5pdGlhbEZvY3VzVGltZXIgPSB2b2lkIDA7XG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVycygpO1xuICAgICAgdGhpcy5zdGF0ZS5hY3RpdmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuc3RhdGUucGF1c2VkID0gZmFsc2U7XG4gICAgICB0aGlzLnVwZGF0ZU9ic2VydmVkTm9kZXMoKTtcbiAgICAgIGFjdGl2ZUZvY3VzVHJhcHMuZGVhY3RpdmF0ZVRyYXAodGhpcy50cmFwU3RhY2ssIHRoaXMpO1xuICAgICAgY29uc3Qgb25EZWFjdGl2YXRlID0gdGhpcy5nZXRPcHRpb24ob3B0aW9ucywgXCJvbkRlYWN0aXZhdGVcIik7XG4gICAgICBjb25zdCBvblBvc3REZWFjdGl2YXRlID0gdGhpcy5nZXRPcHRpb24ob3B0aW9ucywgXCJvblBvc3REZWFjdGl2YXRlXCIpO1xuICAgICAgY29uc3QgY2hlY2tDYW5SZXR1cm5Gb2N1cyA9IHRoaXMuZ2V0T3B0aW9uKG9wdGlvbnMsIFwiY2hlY2tDYW5SZXR1cm5Gb2N1c1wiKTtcbiAgICAgIGNvbnN0IHJldHVybkZvY3VzID0gdGhpcy5nZXRPcHRpb24ob3B0aW9ucywgXCJyZXR1cm5Gb2N1c1wiLCBcInJldHVybkZvY3VzT25EZWFjdGl2YXRlXCIpO1xuICAgICAgb25EZWFjdGl2YXRlPy4oKTtcbiAgICAgIGNvbnN0IGZpbmlzaERlYWN0aXZhdGlvbiA9ICgpID0+IHtcbiAgICAgICAgZGVsYXkoKCkgPT4ge1xuICAgICAgICAgIGlmIChyZXR1cm5Gb2N1cykge1xuICAgICAgICAgICAgY29uc3QgcmV0dXJuRm9jdXNOb2RlID0gdGhpcy5nZXRSZXR1cm5Gb2N1c05vZGUodGhpcy5zdGF0ZS5ub2RlRm9jdXNlZEJlZm9yZUFjdGl2YXRpb24pO1xuICAgICAgICAgICAgdGhpcy50cnlGb2N1cyhyZXR1cm5Gb2N1c05vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvblBvc3REZWFjdGl2YXRlPy4oKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgaWYgKHJldHVybkZvY3VzICYmIGNoZWNrQ2FuUmV0dXJuRm9jdXMpIHtcbiAgICAgICAgY29uc3QgcmV0dXJuRm9jdXNOb2RlID0gdGhpcy5nZXRSZXR1cm5Gb2N1c05vZGUodGhpcy5zdGF0ZS5ub2RlRm9jdXNlZEJlZm9yZUFjdGl2YXRpb24pO1xuICAgICAgICBjaGVja0NhblJldHVybkZvY3VzKHJldHVybkZvY3VzTm9kZSkudGhlbihmaW5pc2hEZWFjdGl2YXRpb24sIGZpbmlzaERlYWN0aXZhdGlvbik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgZmluaXNoRGVhY3RpdmF0aW9uKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicGF1c2VcIiwgKHBhdXNlT3B0aW9ucykgPT4ge1xuICAgICAgaWYgKHRoaXMuc3RhdGUucGF1c2VkIHx8ICF0aGlzLnN0YXRlLmFjdGl2ZSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9uUGF1c2UgPSB0aGlzLmdldE9wdGlvbihwYXVzZU9wdGlvbnMsIFwib25QYXVzZVwiKTtcbiAgICAgIGNvbnN0IG9uUG9zdFBhdXNlID0gdGhpcy5nZXRPcHRpb24ocGF1c2VPcHRpb25zLCBcIm9uUG9zdFBhdXNlXCIpO1xuICAgICAgdGhpcy5zdGF0ZS5wYXVzZWQgPSB0cnVlO1xuICAgICAgb25QYXVzZT8uKCk7XG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVycygpO1xuICAgICAgdGhpcy51cGRhdGVPYnNlcnZlZE5vZGVzKCk7XG4gICAgICBvblBvc3RQYXVzZT8uKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwidW5wYXVzZVwiLCAodW5wYXVzZU9wdGlvbnMpID0+IHtcbiAgICAgIGlmICghdGhpcy5zdGF0ZS5wYXVzZWQgfHwgIXRoaXMuc3RhdGUuYWN0aXZlKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgY29uc3Qgb25VbnBhdXNlID0gdGhpcy5nZXRPcHRpb24odW5wYXVzZU9wdGlvbnMsIFwib25VbnBhdXNlXCIpO1xuICAgICAgY29uc3Qgb25Qb3N0VW5wYXVzZSA9IHRoaXMuZ2V0T3B0aW9uKHVucGF1c2VPcHRpb25zLCBcIm9uUG9zdFVucGF1c2VcIik7XG4gICAgICB0aGlzLnN0YXRlLnBhdXNlZCA9IGZhbHNlO1xuICAgICAgb25VbnBhdXNlPy4oKTtcbiAgICAgIHRoaXMudXBkYXRlVGFiYmFibGVOb2RlcygpO1xuICAgICAgdGhpcy5hZGRMaXN0ZW5lcnMoKTtcbiAgICAgIHRoaXMudXBkYXRlT2JzZXJ2ZWROb2RlcygpO1xuICAgICAgb25Qb3N0VW5wYXVzZT8uKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwidXBkYXRlQ29udGFpbmVyRWxlbWVudHNcIiwgKGNvbnRhaW5lckVsZW1lbnRzKSA9PiB7XG4gICAgICB0aGlzLnN0YXRlLmNvbnRhaW5lcnMgPSBBcnJheS5pc0FycmF5KGNvbnRhaW5lckVsZW1lbnRzKSA/IGNvbnRhaW5lckVsZW1lbnRzLmZpbHRlcihCb29sZWFuKSA6IFtjb250YWluZXJFbGVtZW50c10uZmlsdGVyKEJvb2xlYW4pO1xuICAgICAgaWYgKHRoaXMuc3RhdGUuYWN0aXZlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlVGFiYmFibGVOb2RlcygpO1xuICAgICAgfVxuICAgICAgdGhpcy51cGRhdGVPYnNlcnZlZE5vZGVzKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZ2V0UmV0dXJuRm9jdXNOb2RlXCIsIChwcmV2aW91c0FjdGl2ZUVsZW1lbnQpID0+IHtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLmdldE5vZGVGb3JPcHRpb24oXCJzZXRSZXR1cm5Gb2N1c1wiLCB7XG4gICAgICAgIHBhcmFtczogW3ByZXZpb3VzQWN0aXZlRWxlbWVudF1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG5vZGUgPyBub2RlIDogbm9kZSA9PT0gZmFsc2UgPyBmYWxzZSA6IHByZXZpb3VzQWN0aXZlRWxlbWVudDtcbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZ2V0T3B0aW9uXCIsIChjb25maWdPdmVycmlkZU9wdGlvbnMsIG9wdGlvbk5hbWUsIGNvbmZpZ09wdGlvbk5hbWUpID0+IHtcbiAgICAgIHJldHVybiBjb25maWdPdmVycmlkZU9wdGlvbnMgJiYgY29uZmlnT3ZlcnJpZGVPcHRpb25zW29wdGlvbk5hbWVdICE9PSB2b2lkIDAgPyBjb25maWdPdmVycmlkZU9wdGlvbnNbb3B0aW9uTmFtZV0gOiAoXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgdGhpcy5jb25maWdbY29uZmlnT3B0aW9uTmFtZSB8fCBvcHRpb25OYW1lXVxuICAgICAgKTtcbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZ2V0Tm9kZUZvck9wdGlvblwiLCAob3B0aW9uTmFtZSwgeyBoYXNGYWxsYmFjayA9IGZhbHNlLCBwYXJhbXMgPSBbXSB9ID0ge30pID0+IHtcbiAgICAgIGxldCBvcHRpb25WYWx1ZSA9IHRoaXMuY29uZmlnW29wdGlvbk5hbWVdO1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25WYWx1ZSA9PT0gXCJmdW5jdGlvblwiKSBvcHRpb25WYWx1ZSA9IG9wdGlvblZhbHVlKC4uLnBhcmFtcyk7XG4gICAgICBpZiAob3B0aW9uVmFsdWUgPT09IHRydWUpIG9wdGlvblZhbHVlID0gdm9pZCAwO1xuICAgICAgaWYgKCFvcHRpb25WYWx1ZSkge1xuICAgICAgICBpZiAob3B0aW9uVmFsdWUgPT09IHZvaWQgMCB8fCBvcHRpb25WYWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gb3B0aW9uVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcXGAke29wdGlvbk5hbWV9XFxgIHdhcyBzcGVjaWZpZWQgYnV0IHdhcyBub3QgYSBub2RlLCBvciBkaWQgbm90IHJldHVybiBhIG5vZGVgKTtcbiAgICAgIH1cbiAgICAgIGxldCBub2RlID0gb3B0aW9uVmFsdWU7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvblZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbm9kZSA9IHRoaXMuZG9jLnF1ZXJ5U2VsZWN0b3Iob3B0aW9uVmFsdWUpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFxcYCR7b3B0aW9uTmFtZX1cXGAgYXBwZWFycyB0byBiZSBhbiBpbnZhbGlkIHNlbGVjdG9yOyBlcnJvcj1cIiR7ZXJyLm1lc3NhZ2V9XCJgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICBpZiAoIWhhc0ZhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFxcYCR7b3B0aW9uTmFtZX1cXGAgYXMgc2VsZWN0b3IgcmVmZXJzIHRvIG5vIGtub3duIG5vZGVgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJmaW5kTmV4dE5hdk5vZGVcIiwgKG9wdHMpID0+IHtcbiAgICAgIGNvbnN0IHsgZXZlbnQsIGlzQmFja3dhcmQgPSBmYWxzZSB9ID0gb3B0cztcbiAgICAgIGNvbnN0IHRhcmdldCA9IG9wdHMudGFyZ2V0IHx8IGdldEV2ZW50VGFyZ2V0KGV2ZW50KTtcbiAgICAgIHRoaXMudXBkYXRlVGFiYmFibGVOb2RlcygpO1xuICAgICAgbGV0IGRlc3RpbmF0aW9uTm9kZSA9IG51bGw7XG4gICAgICBpZiAodGhpcy5zdGF0ZS50YWJiYWJsZUdyb3Vwcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lckluZGV4ID0gdGhpcy5maW5kQ29udGFpbmVySW5kZXgodGFyZ2V0LCBldmVudCk7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lckdyb3VwID0gY29udGFpbmVySW5kZXggPj0gMCA/IHRoaXMuc3RhdGUuY29udGFpbmVyR3JvdXBzW2NvbnRhaW5lckluZGV4XSA6IHZvaWQgMDtcbiAgICAgICAgaWYgKGNvbnRhaW5lckluZGV4IDwgMCkge1xuICAgICAgICAgIGlmIChpc0JhY2t3YXJkKSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbk5vZGUgPSB0aGlzLnN0YXRlLnRhYmJhYmxlR3JvdXBzW3RoaXMuc3RhdGUudGFiYmFibGVHcm91cHMubGVuZ3RoIC0gMV0ubGFzdFRhYmJhYmxlTm9kZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVzdGluYXRpb25Ob2RlID0gdGhpcy5zdGF0ZS50YWJiYWJsZUdyb3Vwc1swXS5maXJzdFRhYmJhYmxlTm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaXNCYWNrd2FyZCkge1xuICAgICAgICAgIGxldCBzdGFydE9mR3JvdXBJbmRleCA9IHRoaXMuc3RhdGUudGFiYmFibGVHcm91cHMuZmluZEluZGV4KFxuICAgICAgICAgICAgKHsgZmlyc3RUYWJiYWJsZU5vZGUgfSkgPT4gdGFyZ2V0ID09PSBmaXJzdFRhYmJhYmxlTm9kZVxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKHN0YXJ0T2ZHcm91cEluZGV4IDwgMCAmJiAoY29udGFpbmVyR3JvdXA/LmNvbnRhaW5lciA9PT0gdGFyZ2V0IHx8IGlzRm9jdXNhYmxlKHRhcmdldCkgJiYgIWlzVGFiYmFibGUodGFyZ2V0KSAmJiAhY29udGFpbmVyR3JvdXA/Lm5leHRUYWJiYWJsZU5vZGUodGFyZ2V0LCBmYWxzZSkpKSB7XG4gICAgICAgICAgICBzdGFydE9mR3JvdXBJbmRleCA9IGNvbnRhaW5lckluZGV4O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RhcnRPZkdyb3VwSW5kZXggPj0gMCkge1xuICAgICAgICAgICAgY29uc3QgZGVzdGluYXRpb25Hcm91cEluZGV4ID0gc3RhcnRPZkdyb3VwSW5kZXggPT09IDAgPyB0aGlzLnN0YXRlLnRhYmJhYmxlR3JvdXBzLmxlbmd0aCAtIDEgOiBzdGFydE9mR3JvdXBJbmRleCAtIDE7XG4gICAgICAgICAgICBjb25zdCBkZXN0aW5hdGlvbkdyb3VwID0gdGhpcy5zdGF0ZS50YWJiYWJsZUdyb3Vwc1tkZXN0aW5hdGlvbkdyb3VwSW5kZXhdO1xuICAgICAgICAgICAgZGVzdGluYXRpb25Ob2RlID0gZ2V0VGFiSW5kZXgodGFyZ2V0KSA+PSAwID8gZGVzdGluYXRpb25Hcm91cC5sYXN0VGFiYmFibGVOb2RlIDogZGVzdGluYXRpb25Hcm91cC5sYXN0RG9tVGFiYmFibGVOb2RlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIWlzVGFiRXZlbnQoZXZlbnQpKSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbk5vZGUgPSBjb250YWluZXJHcm91cD8ubmV4dFRhYmJhYmxlTm9kZSh0YXJnZXQsIGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGV0IGxhc3RPZkdyb3VwSW5kZXggPSB0aGlzLnN0YXRlLnRhYmJhYmxlR3JvdXBzLmZpbmRJbmRleChcbiAgICAgICAgICAgICh7IGxhc3RUYWJiYWJsZU5vZGUgfSkgPT4gdGFyZ2V0ID09PSBsYXN0VGFiYmFibGVOb2RlXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAobGFzdE9mR3JvdXBJbmRleCA8IDAgJiYgKGNvbnRhaW5lckdyb3VwPy5jb250YWluZXIgPT09IHRhcmdldCB8fCBpc0ZvY3VzYWJsZSh0YXJnZXQpICYmICFpc1RhYmJhYmxlKHRhcmdldCkgJiYgIWNvbnRhaW5lckdyb3VwPy5uZXh0VGFiYmFibGVOb2RlKHRhcmdldCkpKSB7XG4gICAgICAgICAgICBsYXN0T2ZHcm91cEluZGV4ID0gY29udGFpbmVySW5kZXg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChsYXN0T2ZHcm91cEluZGV4ID49IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGRlc3RpbmF0aW9uR3JvdXBJbmRleCA9IGxhc3RPZkdyb3VwSW5kZXggPT09IHRoaXMuc3RhdGUudGFiYmFibGVHcm91cHMubGVuZ3RoIC0gMSA/IDAgOiBsYXN0T2ZHcm91cEluZGV4ICsgMTtcbiAgICAgICAgICAgIGNvbnN0IGRlc3RpbmF0aW9uR3JvdXAgPSB0aGlzLnN0YXRlLnRhYmJhYmxlR3JvdXBzW2Rlc3RpbmF0aW9uR3JvdXBJbmRleF07XG4gICAgICAgICAgICBkZXN0aW5hdGlvbk5vZGUgPSBnZXRUYWJJbmRleCh0YXJnZXQpID49IDAgPyBkZXN0aW5hdGlvbkdyb3VwLmZpcnN0VGFiYmFibGVOb2RlIDogZGVzdGluYXRpb25Hcm91cC5maXJzdERvbVRhYmJhYmxlTm9kZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFpc1RhYkV2ZW50KGV2ZW50KSkge1xuICAgICAgICAgICAgZGVzdGluYXRpb25Ob2RlID0gY29udGFpbmVyR3JvdXA/Lm5leHRUYWJiYWJsZU5vZGUodGFyZ2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlc3RpbmF0aW9uTm9kZSA9IHRoaXMuZ2V0Tm9kZUZvck9wdGlvbihcImZhbGxiYWNrRm9jdXNcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVzdGluYXRpb25Ob2RlO1xuICAgIH0pO1xuICAgIHRoaXMudHJhcFN0YWNrID0gb3B0aW9ucy50cmFwU3RhY2sgfHwgc2hhcmVkVHJhcFN0YWNrO1xuICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgIHJldHVybkZvY3VzT25EZWFjdGl2YXRlOiB0cnVlLFxuICAgICAgZXNjYXBlRGVhY3RpdmF0ZXM6IHRydWUsXG4gICAgICBkZWxheUluaXRpYWxGb2N1czogdHJ1ZSxcbiAgICAgIGlzS2V5Rm9yd2FyZChlKSB7XG4gICAgICAgIHJldHVybiBpc1RhYkV2ZW50KGUpICYmICFlLnNoaWZ0S2V5O1xuICAgICAgfSxcbiAgICAgIGlzS2V5QmFja3dhcmQoZSkge1xuICAgICAgICByZXR1cm4gaXNUYWJFdmVudChlKSAmJiBlLnNoaWZ0S2V5O1xuICAgICAgfSxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9O1xuICAgIHRoaXMuZG9jID0gY29uZmlnLmRvY3VtZW50IHx8IGdldERvY3VtZW50KEFycmF5LmlzQXJyYXkoZWxlbWVudHMpID8gZWxlbWVudHNbMF0gOiBlbGVtZW50cyk7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy51cGRhdGVDb250YWluZXJFbGVtZW50cyhlbGVtZW50cyk7XG4gICAgdGhpcy5zZXR1cE11dGF0aW9uT2JzZXJ2ZXIoKTtcbiAgfVxuICBnZXQgYWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLmFjdGl2ZTtcbiAgfVxuICBnZXQgcGF1c2VkKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLnBhdXNlZDtcbiAgfVxuICBmaW5kQ29udGFpbmVySW5kZXgoZWxlbWVudCwgZXZlbnQpIHtcbiAgICBjb25zdCBjb21wb3NlZFBhdGggPSB0eXBlb2YgZXZlbnQ/LmNvbXBvc2VkUGF0aCA9PT0gXCJmdW5jdGlvblwiID8gZXZlbnQuY29tcG9zZWRQYXRoKCkgOiB2b2lkIDA7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuY29udGFpbmVyR3JvdXBzLmZpbmRJbmRleChcbiAgICAgICh7IGNvbnRhaW5lciwgdGFiYmFibGVOb2RlcyB9KSA9PiBjb250YWluZXIuY29udGFpbnMoZWxlbWVudCkgfHwgY29tcG9zZWRQYXRoPy5pbmNsdWRlcyhjb250YWluZXIpIHx8IHRhYmJhYmxlTm9kZXMuZmluZCgobm9kZSkgPT4gbm9kZSA9PT0gZWxlbWVudClcbiAgICApO1xuICB9XG4gIHVwZGF0ZVRhYmJhYmxlTm9kZXMoKSB7XG4gICAgdGhpcy5zdGF0ZS5jb250YWluZXJHcm91cHMgPSB0aGlzLnN0YXRlLmNvbnRhaW5lcnMubWFwKChjb250YWluZXIpID0+IHtcbiAgICAgIGNvbnN0IHRhYmJhYmxlTm9kZXMgPSBnZXRUYWJiYWJsZXMoY29udGFpbmVyKTtcbiAgICAgIGNvbnN0IGZvY3VzYWJsZU5vZGVzID0gZ2V0Rm9jdXNhYmxlcyhjb250YWluZXIpO1xuICAgICAgY29uc3QgZmlyc3RUYWJiYWJsZU5vZGUgPSB0YWJiYWJsZU5vZGVzLmxlbmd0aCA+IDAgPyB0YWJiYWJsZU5vZGVzWzBdIDogdm9pZCAwO1xuICAgICAgY29uc3QgbGFzdFRhYmJhYmxlTm9kZSA9IHRhYmJhYmxlTm9kZXMubGVuZ3RoID4gMCA/IHRhYmJhYmxlTm9kZXNbdGFiYmFibGVOb2Rlcy5sZW5ndGggLSAxXSA6IHZvaWQgMDtcbiAgICAgIGNvbnN0IGZpcnN0RG9tVGFiYmFibGVOb2RlID0gZm9jdXNhYmxlTm9kZXMuZmluZCgobm9kZSkgPT4gaXNUYWJiYWJsZShub2RlKSk7XG4gICAgICBjb25zdCBsYXN0RG9tVGFiYmFibGVOb2RlID0gZm9jdXNhYmxlTm9kZXMuc2xpY2UoKS5yZXZlcnNlKCkuZmluZCgobm9kZSkgPT4gaXNUYWJiYWJsZShub2RlKSk7XG4gICAgICBjb25zdCBwb3NUYWJJbmRleGVzRm91bmQgPSAhIXRhYmJhYmxlTm9kZXMuZmluZCgobm9kZSkgPT4gZ2V0VGFiSW5kZXgobm9kZSkgPiAwKTtcbiAgICAgIGZ1bmN0aW9uIG5leHRUYWJiYWJsZU5vZGUobm9kZSwgZm9yd2FyZCA9IHRydWUpIHtcbiAgICAgICAgY29uc3Qgbm9kZUlkeCA9IHRhYmJhYmxlTm9kZXMuaW5kZXhPZihub2RlKTtcbiAgICAgICAgaWYgKG5vZGVJZHggPCAwKSB7XG4gICAgICAgICAgaWYgKGZvcndhcmQpIHtcbiAgICAgICAgICAgIHJldHVybiBmb2N1c2FibGVOb2Rlcy5zbGljZShmb2N1c2FibGVOb2Rlcy5pbmRleE9mKG5vZGUpICsgMSkuZmluZCgoZWwpID0+IGlzVGFiYmFibGUoZWwpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZvY3VzYWJsZU5vZGVzLnNsaWNlKDAsIGZvY3VzYWJsZU5vZGVzLmluZGV4T2Yobm9kZSkpLnJldmVyc2UoKS5maW5kKChlbCkgPT4gaXNUYWJiYWJsZShlbCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YWJiYWJsZU5vZGVzW25vZGVJZHggKyAoZm9yd2FyZCA/IDEgOiAtMSldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICB0YWJiYWJsZU5vZGVzLFxuICAgICAgICBmb2N1c2FibGVOb2RlcyxcbiAgICAgICAgcG9zVGFiSW5kZXhlc0ZvdW5kLFxuICAgICAgICBmaXJzdFRhYmJhYmxlTm9kZSxcbiAgICAgICAgbGFzdFRhYmJhYmxlTm9kZSxcbiAgICAgICAgZmlyc3REb21UYWJiYWJsZU5vZGUsXG4gICAgICAgIGxhc3REb21UYWJiYWJsZU5vZGUsXG4gICAgICAgIG5leHRUYWJiYWJsZU5vZGVcbiAgICAgIH07XG4gICAgfSk7XG4gICAgdGhpcy5zdGF0ZS50YWJiYWJsZUdyb3VwcyA9IHRoaXMuc3RhdGUuY29udGFpbmVyR3JvdXBzLmZpbHRlcigoZ3JvdXApID0+IGdyb3VwLnRhYmJhYmxlTm9kZXMubGVuZ3RoID4gMCk7XG4gICAgaWYgKHRoaXMuc3RhdGUudGFiYmFibGVHcm91cHMubGVuZ3RoIDw9IDAgJiYgIXRoaXMuZ2V0Tm9kZUZvck9wdGlvbihcImZhbGxiYWNrRm9jdXNcIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJZb3VyIGZvY3VzLXRyYXAgbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBjb250YWluZXIgd2l0aCBhdCBsZWFzdCBvbmUgdGFiYmFibGUgbm9kZSBpbiBpdCBhdCBhbGwgdGltZXNcIlxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuc3RhdGUuY29udGFpbmVyR3JvdXBzLmZpbmQoKGcpID0+IGcucG9zVGFiSW5kZXhlc0ZvdW5kKSAmJiB0aGlzLnN0YXRlLmNvbnRhaW5lckdyb3Vwcy5sZW5ndGggPiAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiQXQgbGVhc3Qgb25lIG5vZGUgd2l0aCBhIHBvc2l0aXZlIHRhYmluZGV4IHdhcyBmb3VuZCBpbiBvbmUgb2YgeW91ciBmb2N1cy10cmFwJ3MgbXVsdGlwbGUgY29udGFpbmVycy4gUG9zaXRpdmUgdGFiaW5kZXhlcyBhcmUgb25seSBzdXBwb3J0ZWQgaW4gc2luZ2xlLWNvbnRhaW5lciBmb2N1cy10cmFwcy5cIlxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgYWRkTGlzdGVuZXJzKCkge1xuICAgIGlmICghdGhpcy5zdGF0ZS5hY3RpdmUpIHJldHVybjtcbiAgICBhY3RpdmVGb2N1c1RyYXBzLmFjdGl2YXRlVHJhcCh0aGlzLnRyYXBTdGFjaywgdGhpcyk7XG4gICAgdGhpcy5zdGF0ZS5kZWxheUluaXRpYWxGb2N1c1RpbWVyID0gdGhpcy5jb25maWcuZGVsYXlJbml0aWFsRm9jdXMgPyBkZWxheSgoKSA9PiB7XG4gICAgICB0aGlzLnRyeUZvY3VzKHRoaXMuZ2V0SW5pdGlhbEZvY3VzTm9kZSgpKTtcbiAgICB9KSA6IHRoaXMudHJ5Rm9jdXModGhpcy5nZXRJbml0aWFsRm9jdXNOb2RlKCkpO1xuICAgIHRoaXMubGlzdGVuZXJDbGVhbnVwcy5wdXNoKFxuICAgICAgYWRkRG9tRXZlbnQodGhpcy5kb2MsIFwiZm9jdXNpblwiLCB0aGlzLmhhbmRsZUZvY3VzLCB0cnVlKSxcbiAgICAgIGFkZERvbUV2ZW50KHRoaXMuZG9jLCBcIm1vdXNlZG93blwiLCB0aGlzLmhhbmRsZVBvaW50ZXJEb3duLCB7IGNhcHR1cmU6IHRydWUsIHBhc3NpdmU6IGZhbHNlIH0pLFxuICAgICAgYWRkRG9tRXZlbnQodGhpcy5kb2MsIFwidG91Y2hzdGFydFwiLCB0aGlzLmhhbmRsZVBvaW50ZXJEb3duLCB7IGNhcHR1cmU6IHRydWUsIHBhc3NpdmU6IGZhbHNlIH0pLFxuICAgICAgYWRkRG9tRXZlbnQodGhpcy5kb2MsIFwiY2xpY2tcIiwgdGhpcy5oYW5kbGVDbGljaywgeyBjYXB0dXJlOiB0cnVlLCBwYXNzaXZlOiBmYWxzZSB9KSxcbiAgICAgIGFkZERvbUV2ZW50KHRoaXMuZG9jLCBcImtleWRvd25cIiwgdGhpcy5oYW5kbGVUYWJLZXksIHsgY2FwdHVyZTogdHJ1ZSwgcGFzc2l2ZTogZmFsc2UgfSksXG4gICAgICBhZGREb21FdmVudCh0aGlzLmRvYywgXCJrZXlkb3duXCIsIHRoaXMuaGFuZGxlRXNjYXBlS2V5KVxuICAgICk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVtb3ZlTGlzdGVuZXJzKCkge1xuICAgIGlmICghdGhpcy5zdGF0ZS5hY3RpdmUpIHJldHVybjtcbiAgICB0aGlzLmxpc3RlbmVyQ2xlYW51cHMuZm9yRWFjaCgoY2xlYW51cCkgPT4gY2xlYW51cCgpKTtcbiAgICB0aGlzLmxpc3RlbmVyQ2xlYW51cHMgPSBbXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBhY3RpdmF0ZShhY3RpdmF0ZU9wdGlvbnMpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5hY3RpdmUpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjb25zdCBvbkFjdGl2YXRlID0gdGhpcy5nZXRPcHRpb24oYWN0aXZhdGVPcHRpb25zLCBcIm9uQWN0aXZhdGVcIik7XG4gICAgY29uc3Qgb25Qb3N0QWN0aXZhdGUgPSB0aGlzLmdldE9wdGlvbihhY3RpdmF0ZU9wdGlvbnMsIFwib25Qb3N0QWN0aXZhdGVcIik7XG4gICAgY29uc3QgY2hlY2tDYW5Gb2N1c1RyYXAgPSB0aGlzLmdldE9wdGlvbihhY3RpdmF0ZU9wdGlvbnMsIFwiY2hlY2tDYW5Gb2N1c1RyYXBcIik7XG4gICAgaWYgKCFjaGVja0NhbkZvY3VzVHJhcCkge1xuICAgICAgdGhpcy51cGRhdGVUYWJiYWJsZU5vZGVzKCk7XG4gICAgfVxuICAgIHRoaXMuc3RhdGUuYWN0aXZlID0gdHJ1ZTtcbiAgICB0aGlzLnN0YXRlLnBhdXNlZCA9IGZhbHNlO1xuICAgIHRoaXMuc3RhdGUubm9kZUZvY3VzZWRCZWZvcmVBY3RpdmF0aW9uID0gdGhpcy5kb2MuYWN0aXZlRWxlbWVudCB8fCBudWxsO1xuICAgIG9uQWN0aXZhdGU/LigpO1xuICAgIGNvbnN0IGZpbmlzaEFjdGl2YXRpb24gPSAoKSA9PiB7XG4gICAgICBpZiAoY2hlY2tDYW5Gb2N1c1RyYXApIHtcbiAgICAgICAgdGhpcy51cGRhdGVUYWJiYWJsZU5vZGVzKCk7XG4gICAgICB9XG4gICAgICB0aGlzLmFkZExpc3RlbmVycygpO1xuICAgICAgdGhpcy51cGRhdGVPYnNlcnZlZE5vZGVzKCk7XG4gICAgICBvblBvc3RBY3RpdmF0ZT8uKCk7XG4gICAgfTtcbiAgICBpZiAoY2hlY2tDYW5Gb2N1c1RyYXApIHtcbiAgICAgIGNoZWNrQ2FuRm9jdXNUcmFwKHRoaXMuc3RhdGUuY29udGFpbmVycy5jb25jYXQoKSkudGhlbihmaW5pc2hBY3RpdmF0aW9uLCBmaW5pc2hBY3RpdmF0aW9uKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBmaW5pc2hBY3RpdmF0aW9uKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn07XG52YXIgaXNUYWJFdmVudCA9IChldmVudCkgPT4gZXZlbnQua2V5ID09PSBcIlRhYlwiO1xudmFyIHZhbHVlT3JIYW5kbGVyID0gKHZhbHVlLCAuLi5wYXJhbXMpID0+IHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiID8gdmFsdWUoLi4ucGFyYW1zKSA6IHZhbHVlO1xudmFyIGlzRXNjYXBlRXZlbnQgPSAoZXZlbnQpID0+ICFldmVudC5pc0NvbXBvc2luZyAmJiBldmVudC5rZXkgPT09IFwiRXNjYXBlXCI7XG52YXIgZGVsYXkgPSAoZm4pID0+IHNldFRpbWVvdXQoZm4sIDApO1xudmFyIGlzU2VsZWN0YWJsZUlucHV0ID0gKG5vZGUpID0+IG5vZGUubG9jYWxOYW1lID09PSBcImlucHV0XCIgJiYgXCJzZWxlY3RcIiBpbiBub2RlICYmIHR5cGVvZiBub2RlLnNlbGVjdCA9PT0gXCJmdW5jdGlvblwiO1xuXG4vLyBzcmMvaW5kZXgudHNcbmZ1bmN0aW9uIHRyYXBGb2N1cyhlbCwgb3B0aW9ucyA9IHt9KSB7XG4gIGxldCB0cmFwO1xuICBjb25zdCBjbGVhbnVwID0gcmFmKCgpID0+IHtcbiAgICBjb25zdCBjb250ZW50RWwgPSB0eXBlb2YgZWwgPT09IFwiZnVuY3Rpb25cIiA/IGVsKCkgOiBlbDtcbiAgICBpZiAoIWNvbnRlbnRFbCkgcmV0dXJuO1xuICAgIHRyYXAgPSBuZXcgRm9jdXNUcmFwKGNvbnRlbnRFbCwge1xuICAgICAgZXNjYXBlRGVhY3RpdmF0ZXM6IGZhbHNlLFxuICAgICAgYWxsb3dPdXRzaWRlQ2xpY2s6IHRydWUsXG4gICAgICBwcmV2ZW50U2Nyb2xsOiB0cnVlLFxuICAgICAgcmV0dXJuRm9jdXNPbkRlYWN0aXZhdGU6IHRydWUsXG4gICAgICBkZWxheUluaXRpYWxGb2N1czogZmFsc2UsXG4gICAgICBmYWxsYmFja0ZvY3VzOiBjb250ZW50RWwsXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgZG9jdW1lbnQ6IGdldERvY3VtZW50KGNvbnRlbnRFbClcbiAgICB9KTtcbiAgICB0cnkge1xuICAgICAgdHJhcC5hY3RpdmF0ZSgpO1xuICAgIH0gY2F0Y2gge1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIHRyYXA/LmRlYWN0aXZhdGUoKTtcbiAgICBjbGVhbnVwKCk7XG4gIH07XG59XG5cbmV4cG9ydCB7IEZvY3VzVHJhcCwgdHJhcEZvY3VzIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@zag-js+focus-trap@1.21.7/node_modules/@zag-js/focus-trap/dist/index.mjs\n");

/***/ })

};
;